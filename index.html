<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centuar AI</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        #chessboard {
            width: 480px;
            height: 480px;
            margin: 20px auto;
            border: 2px solid #000;
            position: relative;
        }

        .square {
            width: 60px;
            height: 60px;
            float: left;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            user-select: none;
        }

        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        
        .square:hover {
            opacity: 0.8;
        }
        
        .selected {
            background-color: #87CEEB !important;
            box-shadow: inset 0 0 10px rgba(0,0,255,0.5);
        }
        
        .possible-move {
            background-color: #90EE90 !important;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background: #5a6fd8;
        }

        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            background: #f9f9f9;
        }

        .thinking {
            text-align: center;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }

        .move-history {
            max-height: 150px;
            overflow-y: auto;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Chess AI ‚ôõ</h1>
        
        <div class="game-info">
            <strong>Current Player:</strong> <span id="current-player">White</span><br>
            <strong>You are playing as:</strong> <span id="player-side">White</span>
        </div>
        
        <div id="status" class="status">White to move</div>
        <div id="thinking" class="thinking" style="display: none;">ü§î AI is thinking...</div>
        
        <div id="chessboard"></div>
        
        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="undoMove()">Undo Move</button>
            <button onclick="switchSides()">Switch Sides</button>
        </div>
        
        <div class="move-history">
            <strong>Move History:</strong>
            <div id="move-list"></div>
        </div>
    </div>

    <script>
        // Simple chess board setup
        let board = [
            ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
            ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
            ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
        ];

        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameHistory = [];
        let moveHistory = [];
        let gameOver = false;
        let humanPlayer = 'white'; // Which side the human is playing
        let aiDepth = 4; // AI search depth (increased)
        let moveCount = 0; // Track move number for opening book
        
        // Castling rights
        let castlingRights = {
            whiteKingside: true,
            whiteQueenside: true,
            blackKingside: true,
            blackQueenside: true
        };
        
        // En passant target square
        let enPassantTarget = null;

        // Piece mappings
        const pieceMap = {
            '‚ôú': 'r', '‚ôû': 'n', '‚ôù': 'b', '‚ôõ': 'q', '‚ôö': 'k', '‚ôü': 'p',
            '‚ôñ': 'R', '‚ôò': 'N', '‚ôó': 'B', '‚ôï': 'Q', '‚ôî': 'K', '‚ôô': 'P'
        };

        const symbolMap = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
        };

        function createBoard() {
            const boardElement = document.getElementById('chessboard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.id = `square-${row}-${col}`;
                    
                    // Alternate colors
                    if ((row + col) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }
                    
                    // Add piece
                    square.textContent = board[row][col];
                    
                    // Add click handler
                    square.onclick = () => handleSquareClick(row, col);
                    
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameOver || currentPlayer !== humanPlayer) return;
            
            const square = document.getElementById(`square-${row}-${col}`);
            const piece = board[row][col];
            
            if (selectedSquare) {
                // Try to make a move
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;
                
                if (fromRow === row && fromCol === col) {
                    // Clicking same square - deselect
                    clearSelection();
                    return;
                }
                
                if (isValidMove(fromRow, fromCol, row, col)) {
                    makeMove(fromRow, fromCol, row, col);
                    clearSelection();
                    switchPlayer();
                    updateStatus();
                    
                    if (!gameOver && currentPlayer !== humanPlayer) {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    // Select new piece if it belongs to current player
                    if (piece && isPlayerPiece(piece, currentPlayer)) {
                        selectSquare(row, col);
                    } else {
                        clearSelection();
                    }
                }
            } else {
                // Select piece if it belongs to current player
                if (piece && isPlayerPiece(piece, currentPlayer)) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            clearSelection();
            selectedSquare = { row, col };
            document.getElementById(`square-${row}-${col}`).classList.add('selected');
            showPossibleMoves(row, col);
        }

        function clearSelection() {
            selectedSquare = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'possible-move');
                sq.style.backgroundColor = ''; // Clear special colors
            });
            
            // Restore original colors
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.getElementById(`square-${row}-${col}`);
                    if ((row + col) % 2 === 0) {
                        square.className = 'square light';
                    } else {
                        square.className = 'square dark';
                    }
                    square.textContent = board[row][col];
                }
            }
        }

        function showPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.getElementById(`square-${r}-${c}`);
                        square.classList.add('possible-move');
                        
                        // Special highlighting for castling
                        const piece = board[row][col];
                        if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(c - col) === 2) {
                            square.style.backgroundColor = '#FFD700'; // Gold for castling
                        }
                        
                        // Special highlighting for en passant
                        if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                            r === enPassantTarget.row && c === enPassantTarget.col) {
                            square.style.backgroundColor = '#FF69B4'; // Pink for en passant
                        }
                    }
                }
            }
        }

        function isPlayerPiece(piece, player) {
            if (!piece) return false;
            const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
            const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
            
            if (player === 'white') {
                return whitePieces.includes(piece);
            } else {
                return blackPieces.includes(piece);
            }
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            if (!piece) return false;
            if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) return false;
            
            // Check for castling
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                return canCastle(fromRow, fromCol, toRow, toCol);
            }
            
            // Check for en passant
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(toCol - fromCol) === 1 && !targetPiece && enPassantTarget) {
                if (toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                    return true;
                }
            }
            
            // Check basic piece movement
            const pieceCode = pieceMap[piece];
            if (!isValidPieceMove(pieceCode, fromRow, fromCol, toRow, toCol)) return false;
            
            // Test if move would leave king in check
            const tempBoard = board.map(row => [...row]);
            const tempEnPassant = enPassantTarget;
            
            // Handle en passant capture in test
            if ((piece === '‚ôô' || piece === '‚ôü') && toRow === enPassantTarget?.row && toCol === enPassantTarget?.col) {
                const capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                tempBoard[capturedPawnRow][toCol] = '';
            }
            
            tempBoard[toRow][toCol] = piece;
            tempBoard[fromRow][fromCol] = '';
            
            return !isKingInCheck(tempBoard, currentPlayer);
        }

        function canCastle(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const isWhite = piece === '‚ôî';
            const isKingside = toCol > fromCol;
            
            // Check castling rights
            if (isWhite) {
                if (isKingside && !castlingRights.whiteKingside) return false;
                if (!isKingside && !castlingRights.whiteQueenside) return false;
            } else {
                if (isKingside && !castlingRights.blackKingside) return false;
                if (!isKingside && !castlingRights.blackQueenside) return false;
            }
            
            // Check if king is in check
            if (isKingInCheck(board, currentPlayer)) return false;
            
            // Check if path is clear and king doesn't move through check
            const rookCol = isKingside ? 7 : 0;
            const direction = isKingside ? 1 : -1;
            
            // Check if rook is in correct position
            const expectedRook = isWhite ? '‚ôñ' : '‚ôú';
            if (board[fromRow][rookCol] !== expectedRook) return false;
            
            // Check squares between king and rook are empty
            const start = Math.min(fromCol, rookCol) + 1;
            const end = Math.max(fromCol, rookCol);
            
            for (let col = start; col < end; col++) {
                if (board[fromRow][col] !== '') return false;
            }
            
            // Check king doesn't move through check
            for (let col = fromCol; col !== toCol + direction; col += direction) {
                const testBoard = board.map(row => [...row]);
                testBoard[fromRow][col] = piece;
                testBoard[fromRow][fromCol] = '';
                
                if (isKingInCheck(testBoard, currentPlayer)) return false;
            }
            
            return true;
        }

        function isValidPieceMove(piece, fromRow, fromCol, toRow, toCol) {
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (piece.toLowerCase()) {
                case 'p':
                    const direction = piece === 'P' ? -1 : 1;
                    const startRow = piece === 'P' ? 6 : 1;
                    
                    if (dx === 0) { // Moving forward
                        if (dy === direction && !board[toRow][toCol]) return true;
                        if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol]) return true;
                    } else if (absDx === 1 && dy === direction && board[toRow][toCol]) {
                        return true; // Capturing
                    }
                    return false;
                    
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    
                case 'b':
                    return absDx === absDy && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'k':
                    return absDx <= 1 && absDy <= 1;
                    
                default:
                    return false;
            }
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Save state for undo
            gameHistory.push({
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                moveHistory: [...moveHistory],
                moveCount: moveCount,
                castlingRights: { ...castlingRights },
                enPassantTarget: enPassantTarget
            });
            
            // Handle castling
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const rook = board[fromRow][rookFromCol];
                
                // Move rook
                board[fromRow][rookToCol] = rook;
                board[fromRow][rookFromCol] = '';
            }
            
            // Handle en passant capture
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                const capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = '';
            }
            
            // Make the move
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            // Handle pawn promotion
            if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                const promotedPiece = getPromotionPiece(piece);
                board[toRow][toCol] = promotedPiece;
            }
            
            // Update castling rights
            updateCastlingRights(piece, fromRow, fromCol, toRow, toCol);
            
            // Update en passant target
            updateEnPassantTarget(piece, fromRow, toRow, toCol);
            
            // Increment move counter
            if (currentPlayer === 'white') {
                moveCount++;
            }
            
            // Record move in algebraic notation
            const moveNotation = getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece);
            moveHistory.push(moveNotation);
            updateMoveHistory();
            
            createBoard();
        }

        function getPromotionPiece(pawn) {
            // For AI, always promote to queen (best piece)
            if (currentPlayer !== humanPlayer) {
                return pawn === '‚ôô' ? '‚ôï' : '‚ôõ';
            }
            
            // For human player, ask for choice
            const isWhite = pawn === '‚ôô';
            const pieces = isWhite ? ['‚ôï', '‚ôñ', '‚ôó', '‚ôò'] : ['‚ôõ', '‚ôú', '‚ôù', '‚ôû'];
            const choices = ['Queen', 'Rook', 'Bishop', 'Knight'];
            
            let choice = 0;
            const userChoice = prompt(`Promote pawn to:\n0 - Queen\n1 - Rook\n2 - Bishop\n3 - Knight`, '0');
            if (userChoice !== null) {
                const num = parseInt(userChoice);
                if (num >= 0 && num <= 3) {
                    choice = num;
                }
            }
            
            return pieces[choice];
        }

        function updateCastlingRights(piece, fromRow, fromCol, toRow, toCol) {
            // King moves
            if (piece === '‚ôî') {
                castlingRights.whiteKingside = false;
                castlingRights.whiteQueenside = false;
            } else if (piece === '‚ôö') {
                castlingRights.blackKingside = false;
                castlingRights.blackQueenside = false;
            }
            
            // Rook moves or is captured
            if (piece === '‚ôñ' || (fromRow === 7 && fromCol === 0)) {
                castlingRights.whiteQueenside = false;
            }
            if (piece === '‚ôñ' || (fromRow === 7 && fromCol === 7)) {
                castlingRights.whiteKingside = false;
            }
            if (piece === '‚ôú' || (fromRow === 0 && fromCol === 0)) {
                castlingRights.blackQueenside = false;
            }
            if (piece === '‚ôú' || (fromRow === 0 && fromCol === 7)) {
                castlingRights.blackKingside = false;
            }
            
            // Rook captured
            if (toRow === 7 && toCol === 0) castlingRights.whiteQueenside = false;
            if (toRow === 7 && toCol === 7) castlingRights.whiteKingside = false;
            if (toRow === 0 && toCol === 0) castlingRights.blackQueenside = false;
            if (toRow === 0 && toCol === 7) castlingRights.blackKingside = false;
        }

        function updateEnPassantTarget(piece, fromRow, toRow, toCol) {
            // Clear previous en passant target
            enPassantTarget = null;
            
            // Check for pawn double move
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {
                    row: piece === '‚ôô' ? fromRow - 1 : fromRow + 1,
                    col: toCol
                };
            }
        }

        function getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
            
            const fromSquare = files[fromCol] + ranks[fromRow];
            const toSquare = files[toCol] + ranks[toRow];
            
            let notation = '';
            const pieceSymbol = piece.toLowerCase();
            
            // Castling notation
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                return toCol > fromCol ? 'O-O' : 'O-O-O';
            }
            
            if (pieceSymbol === '‚ôü' || pieceSymbol === '‚ôô') {
                if (capturedPiece || (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col)) {
                    notation = files[fromCol] + 'x' + toSquare;
                } else {
                    notation = toSquare;
                }
                
                // Add promotion notation
                if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                    const promotedPiece = board[toRow][toCol];
                    const promotionSymbol = promotedPiece === '‚ôï' || promotedPiece === '‚ôõ' ? 'Q' :
                                           promotedPiece === '‚ôñ' || promotedPiece === '‚ôú' ? 'R' :
                                           promotedPiece === '‚ôó' || promotedPiece === '‚ôù' ? 'B' : 'N';
                    notation += '=' + promotionSymbol;
                }
            } else {
                const pieceChar = pieceSymbol === '‚ôû' || pieceSymbol === '‚ôò' ? 'N' :
                                 pieceSymbol === '‚ôù' || pieceSymbol === '‚ôó' ? 'B' :
                                 pieceSymbol === '‚ôú' || pieceSymbol === '‚ôñ' ? 'R' :
                                 pieceSymbol === '‚ôõ' || pieceSymbol === '‚ôï' ? 'Q' :
                                 pieceSymbol === '‚ôö' || pieceSymbol === '‚ôî' ? 'K' : '';
                
                notation = pieceChar + (capturedPiece ? 'x' : '') + toSquare;
            }
            
            return notation;
        }

        function isKingInCheck(testBoard, player) {
            // Find the king
            const kingSymbol = player === 'white' ? '‚ôî' : '‚ôö';
            let kingRow = -1, kingCol = -1;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (testBoard[row][col] === kingSymbol) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            if (kingRow === -1) return false; // King not found
            
            // Check if any enemy piece can attack the king
            const enemyPlayer = player === 'white' ? 'black' : 'white';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = testBoard[row][col];
                    if (piece && isPlayerPiece(piece, enemyPlayer)) {
                        const pieceCode = pieceMap[piece];
                        if (canPieceAttack(pieceCode, row, col, kingRow, kingCol, testBoard)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        function canPieceAttack(piece, fromRow, fromCol, toRow, toCol, testBoard) {
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (piece.toLowerCase()) {
                case 'p':
                    const direction = piece === 'P' ? -1 : 1;
                    return absDx === 1 && dy === direction;
                    
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    
                case 'b':
                    return absDx === absDy && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'k':
                    return absDx <= 1 && absDy <= 1;
                    
                default:
                    return false;
            }
        }

        function isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (testBoard[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
        }

        // Opening book with popular openings
        const openingBook = {
            // Italian Game
            "": [{ move: "e2-e4", weight: 40 }], // 1.e4
            "e7-e5": [{ move: "Ng1-f3", weight: 50 }], // 2.Nf3
            "e7-e5,Nb8-c6": [{ move: "Bf1-c4", weight: 40 }], // 3.Bc4 (Italian)
            
            // Spanish Opening (Ruy Lopez)
            "e7-e5,Nb8-c6": [
                { move: "Bf1-c4", weight: 40 }, // Italian
                { move: "Bf1-b5", weight: 35 }  // Spanish
            ],
            
            // French Defense response
            "e7-e6": [{ move: "d2-d4", weight: 45 }], // 2.d4
            "e7-e6,d7-d5": [{ move: "Nb1-c3", weight: 40 }], // 3.Nc3
            
            // Sicilian Defense response
            "c7-c5": [{ move: "Ng1-f3", weight: 50 }], // 2.Nf3
            "c7-c5,d7-d6": [{ move: "d2-d4", weight: 45 }], // 3.d4
            "c7-c5,Nb8-c6": [{ move: "d2-d4", weight: 45 }],
            
            // Queen's Gambit
            "d7-d5": [{ move: "d2-d4", weight: 45 }], // Also 1.d4
            "d7-d5,Ng8-f6": [{ move: "c2-c4", weight: 40 }], // 2.c4 Queen's Gambit
            
            // King's Indian Defense response
            "Ng8-f6": [{ move: "d2-d4", weight: 45 }],
            "Ng8-f6,g7-g6": [{ move: "c2-c4", weight: 40 }],
            
            // English Opening
            "": [
                { move: "e2-e4", weight: 40 },
                { move: "d2-d4", weight: 35 },
                { move: "c2-c4", weight: 20 }  // English Opening
            ]
        };

        function makeAIMove() {
            if (gameOver) return;
            
            document.getElementById('thinking').style.display = 'block';
            
            setTimeout(() => {
                const aiPlayer = humanPlayer === 'white' ? 'black' : 'white';
                let bestMove = null;
                
                // Use opening book for first 10 moves
                if (moveCount <= 5) {
                    bestMove = getOpeningMove(aiPlayer);
                }
                
                // If no opening move found, use minimax
                if (!bestMove) {
                    bestMove = getBestMoveMinMax(aiPlayer, aiDepth);
                }
                
                if (bestMove) {
                    makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    switchPlayer();
                    updateStatus();
                }
                document.getElementById('thinking').style.display = 'none';
            }, 1200);
        }

        function getOpeningMove(player) {
            // Build current game state string
            const gameState = buildGameStateString();
            
            // Check if current position is in opening book
            if (openingBook[gameState]) {
                const possibleMoves = openingBook[gameState];
                
                // Select move based on weights
                const totalWeight = possibleMoves.reduce((sum, move) => sum + move.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const moveData of possibleMoves) {
                    random -= moveData.weight;
                    if (random <= 0) {
                        return parseOpeningMove(moveData.move, player);
                    }
                }
            }
            
            // If not in book, use basic opening principles
            return getBasicOpeningMove(player);
        }

        function buildGameStateString() {
            // Simple representation of key moves played
            // This is a simplified approach - in practice, you'd want more sophisticated position tracking
            return moveHistory.slice(0, Math.min(moveHistory.length, 6)).join(',');
        }

        function parseOpeningMove(moveStr, player) {
            // Parse moves like "e2-e4" or "Ng1-f3"
            const parts = moveStr.split('-');
            if (parts.length !== 2) return null;
            
            const fromSquare = parts[0];
            const toSquare = parts[1];
            
            // Convert algebraic notation to array indices
            const fromCol = fromSquare.charCodeAt(fromSquare.length - 2) - 97; // 'a' = 0
            const fromRow = 8 - parseInt(fromSquare.charAt(fromSquare.length - 1));
            const toCol = toSquare.charCodeAt(toSquare.length - 2) - 97;
            const toRow = 8 - parseInt(toSquare.charAt(toSquare.length - 1));
            
            // Verify the move is legal
            if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                return { fromRow, fromCol, toRow, toCol };
            }
            
            return null;
        }

        function getBasicOpeningMove(player) {
            const moves = getAllPossibleMoves(player);
            
            // Opening principles priority list
            const priorities = [
                // 1. Control center with pawns
                (move) => {
                    const piece = board[move.fromRow][move.fromCol];
                    if ((piece === '‚ôü' || piece === '‚ôô')) {
                        // e4, d4, e5, d5
                        if ((move.toRow === 4 && (move.toCol === 4 || move.toCol === 3)) ||
                            (move.toRow === 3 && (move.toCol === 4 || move.toCol === 3))) {
                            return 100;
                        }
                        // Other center pawns
                        if (move.toRow >= 2 && move.toRow <= 5 && move.toCol >= 2 && move.toCol <= 5) {
                            return 50;
                        }
                    }
                    return 0;
                },
                
                // 2. Develop knights toward center
                (move) => {
                    const piece = board[move.fromRow][move.fromCol];
                    if (piece === '‚ôû' || piece === '‚ôò') {
                        // Knights to f3, c3, f6, c6
                        if ((move.toRow === 5 && (move.toCol === 5 || move.toCol === 2)) ||
                            (move.toRow === 2 && (move.toCol === 5 || move.toCol === 2))) {
                            return 80;
                        }
                        // Other knight development
                        if (move.toRow >= 2 && move.toRow <= 5 && move.toCol >= 1 && move.toCol <= 6) {
                            return 60;
                        }
                    }
                    return 0;
                },
                
                // 3. Develop bishops
                (move) => {
                    const piece = board[move.fromRow][move.fromCol];
                    if (piece === '‚ôù' || piece === '‚ôó') {
                        // Good bishop squares
                        if ((move.toRow === 4 && move.toCol === 2) || // c4
                            (move.toRow === 3 && move.toCol === 5) || // f5
                            (move.toRow === 2 && move.toCol === 4) || // e6
                            (move.toRow === 5 && move.toCol === 3)) { // d3
                            return 70;
                        }
                        return 40;
                    }
                    return 0;
                },
                
                // 4. Castle early
                (move) => {
                    const piece = board[move.fromRow][move.fromCol];
                    if (piece === '‚ôö' || piece === '‚ôî') {
                        // Castling moves (simplified detection)
                        if (Math.abs(move.toCol - move.fromCol) === 2) {
                            return 90;
                        }
                    }
                    return 0;
                }
            ];
            
            let bestMove = null;
            let bestScore = -1;
            
            for (const move of moves) {
                let score = 0;
                for (const priority of priorities) {
                    score += priority(move);
                }
                
                // Add small random factor
                score += Math.random() * 5;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove || moves[0]; // Fallback to first legal move
        }

        // Advanced AI using Minimax algorithm with Alpha-Beta pruning
        function getBestMoveMinMax(player, depth) {
            let bestScore = player === humanPlayer ? Infinity : -Infinity;
            let bestMove = null;
            const moves = getAllPossibleMoves(player);
            
            // Sort moves to improve alpha-beta pruning efficiency
            moves.sort((a, b) => {
                const scoreA = evaluateMoveQuick(a);
                const scoreB = evaluateMoveQuick(b);
                return player === humanPlayer ? scoreA - scoreB : scoreB - scoreA;
            });
            
            for (const move of moves) {
                // Make the move
                const originalPiece = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                board[move.fromRow][move.fromCol] = '';
                
                const score = minimax(depth - 1, player === 'white' ? 'black' : 'white', -Infinity, Infinity, player !== humanPlayer);
                
                // Undo the move
                board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = originalPiece;
                
                if ((player !== humanPlayer && score > bestScore) || (player === humanPlayer && score < bestScore)) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }

        function minimax(depth, player, alpha, beta, maximizingPlayer) {
            if (depth === 0) {
                return evaluatePosition();
            }
            
            const moves = getAllPossibleMoves(player);
            if (moves.length === 0) {
                if (isKingInCheck(board, player)) {
                    return maximizingPlayer ? -10000 + (aiDepth - depth) : 10000 - (aiDepth - depth);
                }
                return 0; // Stalemate
            }
            
            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const originalPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = '';
                    
                    const eval = minimax(depth - 1, player === 'white' ? 'black' : 'white', alpha, beta, false);
                    
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = originalPiece;
                    
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const originalPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = '';
                    
                    const eval = minimax(depth - 1, player === 'white' ? 'black' : 'white', alpha, beta, true);
                    
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = originalPiece;
                    
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return minEval;
            }
        }

        function evaluatePosition() {
            let score = 0;
            
            // Material and positional evaluation
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const pieceValue = getPieceValue(piece);
                        const positionValue = getPositionValue(piece, row, col);
                        
                        if (isPlayerPiece(piece, 'white')) {
                            score += pieceValue + positionValue;
                        } else {
                            score -= pieceValue + positionValue;
                        }
                    }
                }
            }
            
            // Critical: Check for hanging pieces
            score += evaluateHangingPieces('white') - evaluateHangingPieces('black');
            
            // Advanced evaluations
            score += evaluateCenter();
            score += evaluateKingSafety('white') - evaluateKingSafety('black');
            score += evaluateDevelopment('white') - evaluateDevelopment('black');
            score += evaluatePawnStructure('white') - evaluatePawnStructure('black');
            score += evaluateThreatsMate('white') - evaluateThreatsMate('black');
            
            return humanPlayer === 'white' ? score : -score;
        }

        function evaluateHangingPieces(player) {
            let hangingPenalty = 0;
            const enemy = player === 'white' ? 'black' : 'white';
            
            // Check each piece to see if it's hanging (undefended and attacked)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPlayerPiece(piece, player)) {
                        const pieceValue = getPieceValue(piece);
                        
                        // Check if piece is attacked by enemy
                        const attackedBy = getAttackers(row, col, enemy);
                        if (attackedBy.length > 0) {
                            // Check if piece is defended by friendly pieces
                            const defendedBy = getAttackers(row, col, player);
                            
                            if (defendedBy.length === 0) {
                                // Piece is hanging (attacked but not defended)
                                hangingPenalty -= pieceValue * 0.9; // Almost full piece value penalty
                            } else {
                                // Piece is attacked and defended - evaluate exchange
                                const exchangeValue = evaluateExchange(row, col, attackedBy, defendedBy);
                                hangingPenalty += exchangeValue;
                            }
                        }
                    }
                }
            }
            
            return hangingPenalty;
        }

        function getAttackers(targetRow, targetCol, attackerColor) {
            const attackers = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPlayerPiece(piece, attackerColor)) {
                        // Temporarily clear target square to test if piece can attack it
                        const originalPiece = board[targetRow][targetCol];
                        board[targetRow][targetCol] = attackerColor === 'white' ? '‚ôü' : '‚ôô'; // Dummy enemy piece
                        
                        const tempCurrentPlayer = currentPlayer;
                        currentPlayer = attackerColor;
                        
                        if (isValidMove(row, col, targetRow, targetCol)) {
                            attackers.push({
                                row: row,
                                col: col,
                                piece: piece,
                                value: getPieceValue(piece)
                            });
                        }
                        
                        currentPlayer = tempCurrentPlayer;
                        board[targetRow][targetCol] = originalPiece;
                    }
                }
            }
            
            return attackers;
        }

        function evaluateExchange(targetRow, targetCol, attackers, defenders) {
            if (attackers.length === 0) return 0;
            
            const targetPiece = board[targetRow][targetCol];
            const targetValue = getPieceValue(targetPiece);
            
            // Sort attackers and defenders by piece value (use least valuable first)
            attackers.sort((a, b) => a.value - b.value);
            defenders.sort((a, b) => a.value - b.value);
            
            // Simulate the exchange sequence
            let materialBalance = 0;
            let attackerTurn = true;
            let attackerIndex = 0;
            let defenderIndex = 0;
            let currentTargetValue = targetValue;
            
            // First capture
            if (attackers.length > 0) {
                materialBalance += currentTargetValue; // Attacker gains target
                currentTargetValue = attackers[attackerIndex].value;
                attackerIndex++;
                attackerTurn = false;
            }
            
            // Continue exchange sequence
            while ((attackerTurn && attackerIndex < attackers.length) || 
                   (!attackerTurn && defenderIndex < defenders.length)) {
                
                if (attackerTurn) {
                    // Attacker recaptures
                    materialBalance += currentTargetValue;
                    currentTargetValue = attackers[attackerIndex].value;
                    attackerIndex++;
                } else {
                    // Defender recaptures
                    materialBalance -= currentTargetValue;
                    currentTargetValue = defenders[defenderIndex].value;
                    defenderIndex++;
                }
                
                attackerTurn = !attackerTurn;
            }
            
            return materialBalance;
        }

        function getBestMoveMinMax(player, depth) {
            let bestScore = player === humanPlayer ? Infinity : -Infinity;
            let bestMove = null;
            const moves = getAllPossibleMoves(player);
            
            // Sort moves to improve alpha-beta pruning efficiency
            moves.sort((a, b) => {
                const scoreA = evaluateMoveQuick(a);
                const scoreB = evaluateMoveQuick(b);
                return player === humanPlayer ? scoreA - scoreB : scoreB - scoreA;
            });
            
            for (const move of moves) {
                // Make the move
                const originalPiece = board[move.toRow][move.toCol];
                const movingPiece = board[move.fromRow][move.fromCol];
                board[move.toRow][move.toCol] = movingPiece;
                board[move.fromRow][move.fromCol] = '';
                
                const score = minimax(depth - 1, player === 'white' ? 'black' : 'white', -Infinity, Infinity, player !== humanPlayer);
                
                // Undo the move
                board[move.fromRow][move.fromCol] = movingPiece;
                board[move.toRow][move.toCol] = originalPiece;
                
                if ((player !== humanPlayer && score > bestScore) || (player === humanPlayer && score < bestScore)) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }

        function evaluateMoveQuick(move) {
            let score = 0;
            const movingPiece = board[move.fromRow][move.fromCol];
            const targetPiece = board[move.toRow][move.toCol];
            
            // Capture value
            if (targetPiece) {
                score += getPieceValue(targetPiece);
            }
            
            // Check if moving piece becomes hanging after this move
            const originalTarget = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = movingPiece;
            board[move.fromRow][move.fromCol] = '';
            
            // Check if the moved piece is now hanging
            const playerColor = isPlayerPiece(movingPiece, 'white') ? 'white' : 'black';
            const enemyColor = playerColor === 'white' ? 'black' : 'white';
            
            const attackers = getAttackers(move.toRow, move.toCol, enemyColor);
            const defenders = getAttackers(move.toRow, move.toCol, playerColor);
            
            if (attackers.length > 0 && defenders.length === 0) {
                // Piece becomes hanging
                score -= getPieceValue(movingPiece) * 0.8;
            } else if (attackers.length > 0) {
                // Evaluate potential exchange
                const exchangeValue = evaluateExchange(move.toRow, move.toCol, attackers, defenders);
                if (playerColor === 'white') {
                    score += exchangeValue;
                } else {
                    score -= exchangeValue;
                }
            }
            
            // Restore board
            board[move.fromRow][move.fromCol] = movingPiece;
            board[move.toRow][move.toCol] = originalTarget;
            
            // Prefer center moves
            const centerDistance = Math.abs(move.toRow - 3.5) + Math.abs(move.toCol - 3.5);
            score -= centerDistance * 2;
            
            // Bonus for developing pieces
            if (moveCount < 10) {
                const pieceType = movingPiece.toLowerCase();
                if ((pieceType === '‚ôû' || pieceType === '‚ôò' || 
                     pieceType === '‚ôù' || pieceType === '‚ôó') &&
                    ((isPlayerPiece(movingPiece, 'white') && move.fromRow === 7) ||
                     (isPlayerPiece(movingPiece, 'black') && move.fromRow === 0))) {
                    score += 15; // Development bonus
                }
            }
            
            return score;
        }

        function evaluateDevelopment(player) {
            let development = 0;
            const backRank = player === 'white' ? 7 : 0;
            const isEarlyGame = moveCount < 10;
            
            if (!isEarlyGame) return 0;
            
            // Penalty for pieces still on back rank
            for (let col = 0; col < 8; col++) {
                const piece = board[backRank][col];
                if (piece && isPlayerPiece(piece, player)) {
                    const pieceType = piece.toLowerCase();
                    if (pieceType === '‚ôû' || pieceType === '‚ôò' || 
                        pieceType === '‚ôù' || pieceType === '‚ôó') {
                        development -= 15; // Penalty for undeveloped pieces
                    }
                }
            }
            
            // Bonus for developed pieces
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPlayerPiece(piece, player)) {
                        const pieceType = piece.toLowerCase();
                        if ((pieceType === '‚ôû' || pieceType === '‚ôò') && 
                            ((player === 'white' && row < 7) || (player === 'black' && row > 0))) {
                            development += 10;
                        }
                        if ((pieceType === '‚ôù' || pieceType === '‚ôó') && 
                            ((player === 'white' && row < 7) || (player === 'black' && row > 0))) {
                            development += 8;
                        }
                    }
                }
            }
            
            return development;
        }

        function evaluatePawnStructure(player) {
            let score = 0;
            const direction = player === 'white' ? -1 : 1;
            const pawn = player === 'white' ? '‚ôô' : '‚ôü';
            
            for (let col = 0; col < 8; col++) {
                let pawnCount = 0;
                let advanced = false;
                
                for (let row = 0; row < 8; row++) {
                    if (board[row][col] === pawn) {
                        pawnCount++;
                        // Bonus for advanced pawns
                        const advancement = player === 'white' ? (7 - row) : row;
                        if (advancement > 4) {
                            score += advancement * 5;
                            advanced = true;
                        }
                    }
                }
                
                // Penalty for doubled pawns
                if (pawnCount > 1) {
                    score -= 10 * (pawnCount - 1);
                }
                
                // Bonus for passed pawns (simplified check)
                if (pawnCount === 1 && advanced) {
                    let passed = true;
                    const enemyPawn = player === 'white' ? '‚ôü' : '‚ôô';
                    
                    // Check adjacent files for enemy pawns
                    for (let checkCol = Math.max(0, col - 1); checkCol <= Math.min(7, col + 1); checkCol++) {
                        for (let row = 0; row < 8; row++) {
                            if (board[row][checkCol] === enemyPawn) {
                                const enemyAdvancement = player === 'white' ? row : (7 - row);
                                if (enemyAdvancement < 4) {
                                    passed = false;
                                    break;
                                }
                            }
                        }
                        if (!passed) break;
                    }
                    
                    if (passed) {
                        score += 20;
                    }
                }
            }
            
            return score;
        }

        function evaluateThreatsMate(player) {
            let threats = 0;
            const enemy = player === 'white' ? 'black' : 'white';
            
            // Check for checkmate threats (simplified)
            if (isKingInCheck(board, enemy)) {
                const enemyMoves = getAllPossibleMoves(enemy);
                if (enemyMoves.length === 0) {
                    return 10000; // Checkmate
                } else if (enemyMoves.length < 3) {
                    threats += 100; // Severe pressure
                }
            }
            
            // Look for tactics: forks, pins, skewers (basic detection)
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        threats += evaluateTacticalThreats(piece, fromRow, fromCol, enemy);
                    }
                }
            }
            
            return threats;
        }

        function evaluateTacticalThreats(piece, fromRow, fromCol, enemyColor) {
            let threats = 0;
            const pieceType = piece.toLowerCase();
            
            // Check all possible moves for this piece
            for (let toRow = 0; toRow < 8; toRow++) {
                for (let toCol = 0; toCol < 8; toCol++) {
                    if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                        const targetPiece = board[toRow][toCol];
                        
                        // Direct capture threat
                        if (targetPiece && isPlayerPiece(targetPiece, enemyColor)) {
                            threats += getPieceValue(targetPiece) / 10;
                        }
                        
                        // Fork detection (simplified)
                        if (pieceType === '‚ôû' || pieceType === '‚ôò' || 
                            pieceType === '‚ôü' || pieceType === '‚ôô') {
                            let attackCount = 0;
                            const directions = getAttackDirections(pieceType);
                            
                            for (const [dr, dc] of directions) {
                                const checkRow = toRow + dr;
                                const checkCol = toCol + dc;
                                if (checkRow >= 0 && checkRow < 8 && checkCol >= 0 && checkCol < 8) {
                                    const checkPiece = board[checkRow][checkCol];
                                    if (checkPiece && isPlayerPiece(checkPiece, enemyColor)) {
                                        attackCount++;
                                    }
                                }
                            }
                            
                            if (attackCount >= 2) {
                                threats += 30; // Fork bonus
                            }
                        }
                    }
                }
            }
            
            return threats;
        }

        function getAttackDirections(pieceType) {
            switch (pieceType) {
                case '‚ôû': case '‚ôò':
                    return [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                case '‚ôü': case '‚ôô':
                    return pieceType === '‚ôô' ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]];
                default:
                    return [];
            }
        }

        function getPositionValue(piece, row, col) {
            const pieceType = piece.toLowerCase();
            const isWhite = isPlayerPiece(piece, 'white');
            const adjustedRow = isWhite ? 7 - row : row;
            
            const pawnTable = [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ];
            
            const knightTable = [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ];
            
            const bishopTable = [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ];
            
            switch (pieceType) {
                case '‚ôü': case '‚ôô': return pawnTable[adjustedRow][col] / 10;
                case '‚ôû': case '‚ôò': return knightTable[adjustedRow][col] / 10;
                case '‚ôù': case '‚ôó': return bishopTable[adjustedRow][col] / 10;
                default: return 0;
            }
        }

        function evaluateCenter() {
            let centerControl = 0;
            const centerSquares = [[3,3], [3,4], [4,3], [4,4]];
            const extendedCenter = [[2,2], [2,3], [2,4], [2,5], [3,2], [3,5], [4,2], [4,5], [5,2], [5,3], [5,4], [5,5]];
            
            for (const [row, col] of centerSquares) {
                const piece = board[row][col];
                if (piece) {
                    centerControl += isPlayerPiece(piece, 'white') ? 10 : -10;
                }
            }
            
            for (const [row, col] of extendedCenter) {
                const piece = board[row][col];
                if (piece) {
                    centerControl += isPlayerPiece(piece, 'white') ? 3 : -3;
                }
            }
            
            return centerControl;
        }

        function evaluateKingSafety(player) {
            const king = player === 'white' ? '‚ôî' : '‚ôö';
            let kingRow = -1, kingCol = -1;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === king) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            if (kingRow === -1) return -1000;
            
            let safety = 0;
            
            // Penalty for exposed king
            const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            for (const [dr, dc] of directions) {
                const newRow = kingRow + dr;
                const newCol = kingCol + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const piece = board[newRow][newCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        safety += 5; // Friendly piece nearby
                    }
                }
            }
            
            return safety;
        }

        function evaluateMoveQuick(move) {
            let score = 0;
            const movingPiece = board[move.fromRow][move.fromCol];
            const targetPiece = board[move.toRow][move.toCol];
            
            // Capture value
            if (targetPiece) {
                score += getPieceValue(targetPiece);
            }
            
            // Check if moving piece becomes hanging after this move
            const originalTarget = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = movingPiece;
            board[move.fromRow][move.fromCol] = '';
            
            // Check if the moved piece is now hanging
            const playerColor = isPlayerPiece(movingPiece, 'white') ? 'white' : 'black';
            const enemyColor = playerColor === 'white' ? 'black' : 'white';
            
            const attackers = getAttackers(move.toRow, move.toCol, enemyColor);
            const defenders = getAttackers(move.toRow, move.toCol, playerColor);
            
            if (attackers.length > 0 && defenders.length === 0) {
                // Piece becomes hanging
                score -= getPieceValue(movingPiece) * 0.8;
            } else if (attackers.length > 0) {
                // Evaluate potential exchange
                const exchangeValue = evaluateExchange(move.toRow, move.toCol, attackers, defenders);
                if (playerColor === 'white') {
                    score += exchangeValue;
                } else {
                    score -= exchangeValue;
                }
            }
            
            // Restore board
            board[move.fromRow][move.fromCol] = movingPiece;
            board[move.toRow][move.toCol] = originalTarget;
            
            // Prefer center moves
            const centerDistance = Math.abs(move.toRow - 3.5) + Math.abs(move.toCol - 3.5);
            score -= centerDistance * 2;
            
            // Bonus for developing pieces
            if (moveCount < 10) {
                const pieceType = movingPiece.toLowerCase();
                if ((pieceType === '‚ôû' || pieceType === '‚ôò' || 
                     pieceType === '‚ôù' || pieceType === '‚ôó') &&
                    ((isPlayerPiece(movingPiece, 'white') && move.fromRow === 7) ||
                     (isPlayerPiece(movingPiece, 'black') && move.fromRow === 0))) {
                    score += 15; // Development bonus
                }
            }
            
            return score;
        }

        function getPieceValue(piece) {
            const values = {
                '‚ôô': 100, '‚ôò': 320, '‚ôó': 330, '‚ôñ': 500, '‚ôï': 900, '‚ôî': 20000,
                '‚ôü': 100, '‚ôû': 320, '‚ôù': 330, '‚ôú': 500, '‚ôõ': 900, '‚ôö': 20000
            };
            return values[piece] || 0;
        }

        function getAllPossibleMoves(player) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                const oldPlayer = currentPlayer;
                                currentPlayer = player;
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    moves.push({ fromRow, fromCol, toRow, toCol });
                                }
                                currentPlayer = oldPlayer;
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function updateStatus() {
            const statusElement = document.getElementById('status');
            const playerName = currentPlayer === 'white' ? 'White' : 'Black';
            
            if (isKingInCheck(board, currentPlayer)) {
                const moves = getAllPossibleMoves(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = `Checkmate! ${playerName === 'White' ? 'Black' : 'White'} wins!`;
                    statusElement.style.backgroundColor = '#ffcccb';
                    gameOver = true;
                } else {
                    statusElement.textContent = `${playerName} is in check!`;
                    statusElement.style.backgroundColor = '#ffe4b5';
                }
            } else {
                const moves = getAllPossibleMoves(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = 'Stalemate! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                } else {
                    statusElement.textContent = `${playerName} to move`;
                    statusElement.style.backgroundColor = '#f9f9f9';
                }
            }
        }

        function updateMoveHistory() {
            const moveList = document.getElementById('move-list');
            moveList.innerHTML = moveHistory.map((move, index) => {
                const moveNumber = Math.floor(index / 2) + 1;
                const isWhiteMove = index % 2 === 0;
                return isWhiteMove ? `${moveNumber}. ${move}` : ` ${move}<br>`;
            }).join('');
        }

        function newGame() {
            board = [
                ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
            ];
            
            currentPlayer = 'white';
            selectedSquare = null;
            gameHistory = [];
            moveHistory = [];
            moveCount = 0;
            gameOver = false;
            
            // Reset castling rights
            castlingRights = {
                whiteKingside: true,
                whiteQueenside: true,
                blackKingside: true,
                blackQueenside: true
            };
            
            // Reset en passant
            enPassantTarget = null;
            
            document.getElementById('current-player').textContent = 'White';
            document.getElementById('player-side').textContent = humanPlayer === 'white' ? 'White' : 'Black';
            createBoard();
            updateStatus();
            updateMoveHistory();
            
            // If AI plays first, make AI move
            if (currentPlayer !== humanPlayer) {
                setTimeout(makeAIMove, 1000);
            }
        }

        function switchSides() {
            humanPlayer = humanPlayer === 'white' ? 'black' : 'white';
            document.getElementById('player-side').textContent = humanPlayer === 'white' ? 'White' : 'Black';
            
            clearSelection();
            
            // If it's now AI's turn, make AI move
            if (!gameOver && currentPlayer !== humanPlayer) {
                setTimeout(makeAIMove, 500);
            }
        }

        function undoMove() {
            if (gameHistory.length >= 2) {
                gameHistory.pop(); // Remove current state
                const lastState = gameHistory.pop(); // Get previous state
                
                board = lastState.board;
                currentPlayer = lastState.currentPlayer;
                moveHistory = lastState.moveHistory;
                moveCount = lastState.moveCount;
                gameOver = false;
                
                document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
                clearSelection();
                createBoard();
                updateStatus();
                updateMoveHistory();
            } else if (gameHistory.length === 1) {
                newGame();
            }
        }
        function makeAIMove() {
            if (gameOver) return;
            
            document.getElementById('thinking').style.display = 'block';
            
            setTimeout(() => {
                const aiPlayer = humanPlayer === 'white' ? 'black' : 'white';
                let bestMove = null;
                
                // Use opening book for first 5 moves only (reduced)
                if (moveCount <= 3) {
                    try {
                        bestMove = getOpeningMove(aiPlayer);
                    } catch (e) {
                        console.log("Opening book failed, using minimax");
                        bestMove = null;
                    }
                }
                
                // If no opening move found, use minimax with timeout protection
                if (!bestMove) {
                    try {
                        bestMove = getBestMoveMinMax(aiPlayer, Math.min(aiDepth, 3)); // Reduced depth
                    } catch (e) {
                        console.log("Minimax failed, using random move");
                        const allMoves = getAllPossibleMoves(aiPlayer);
                        if (allMoves.length > 0) {
                            bestMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                        }
                    }
                }
                
                // Final fallback - just pick any legal move
                if (!bestMove) {
                    const allMoves = getAllPossibleMoves(aiPlayer);
                    if (allMoves.length > 0) {
                        bestMove = allMoves[0];
                    }
                }
                
                if (bestMove) {
                    makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    switchPlayer();
                    updateStatus();
                }
                document.getElementById('thinking').style.display = 'none';
            }, 800); // Reduced thinking time
        }
        // Initialize the game
        createBoard();
        updateStatus();
        document.getElementById('player-side').textContent = 'White';
        // New function focused on immediate capture opportunities
        function evaluateImmediateThreats(player) {
            let threats = 0;
            const enemy = player === 'white' ? 'black' : 'white';
            
            // Look for pieces we can capture next move
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        
                        // Check all squares this piece can attack
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                const targetPiece = board[toRow][toCol];
                                
                                if (targetPiece && isPlayerPiece(targetPiece, enemy)) {
                                    const tempCurrentPlayer = currentPlayer;
                                    currentPlayer = player;
                                    
                                    if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                        const captureValue = getPieceValue(targetPiece);
                                        
                                        // Check if it's a safe capture
                                        board[toRow][toCol] = piece;
                                        board[fromRow][fromCol] = '';
                                        
                                        const attackers = getAttackers(toRow, toCol, enemy);
                                        
                                        if (attackers.length === 0) {
                                            // Safe capture - big bonus!
                                            threats += captureValue * 0.8;
                                        } else {
                                            // Risky capture - smaller bonus
                                            threats += captureValue * 0.3;
                                        }
                                        
                                        // Restore board
                                        board[fromRow][fromCol] = piece;
                                        board[toRow][toCol] = targetPiece;
                                    }
                                    
                                    currentPlayer = tempCurrentPlayer;
                                }
                            }
                        }
                    }
                }
            }
            
            return threats;
        }        function makeAIMove() {
            if (gameOver) return;
            
            document.getElementById('thinking').style.display = 'block';
            
            setTimeout(() => {
                const aiPlayer = humanPlayer === 'white' ? 'black' : 'white';
                let bestMove = null;
                
                // Use opening book for first 5 moves only (reduced)
                if (moveCount <= 3) {
                    try {
                        bestMove = getOpeningMove(aiPlayer);
                    } catch (e) {
                        console.log("Opening book failed, using minimax");
                        bestMove = null;
                    }
                }
                
                // If no opening move found, use minimax with timeout protection
                if (!bestMove) {
                    try {
                        bestMove = getBestMoveMinMax(aiPlayer, Math.min(aiDepth, 3)); // Reduced depth
                    } catch (e) {
                        console.log("Minimax failed, using random move");
                        const allMoves = getAllPossibleMoves(aiPlayer);
                        if (allMoves.length > 0) {
                            bestMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                        }
                    }
                }
                
                // Final fallback - just pick any legal move
                if (!bestMove) {
                    const allMoves = getAllPossibleMoves(aiPlayer);
                    if (allMoves.length > 0) {
                        bestMove = allMoves[0];
                    }
                }
                
                if (bestMove) {
                    makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    switchPlayer();
                    updateStatus();
                }
                document.getElementById('thinking').style.display = 'none';
            }, 800); // Reduced thinking time
        }
        // Emergency move finder - handles immediate threats
        function findEmergencyMove(player) {
            const moves = getAllPossibleMoves(player);
            const enemyColor = player === 'white' ? 'black' : 'white';
            
            // First priority: If we're in check, find moves that get us out
            if (isKingInCheck(board, player)) {
                for (const move of moves) {
                    const originalPiece = board[move.toRow][move.toCol];
                    const movingPiece = board[move.fromRow][move.fromCol];
                    board[move.toRow][move.toCol] = movingPiece;
                    board[move.fromRow][move.fromCol] = '';
                    
                    if (!isKingInCheck(board, player)) {
                        // This move gets us out of check
                        board[move.fromRow][move.fromCol] = movingPiece;
                        board[move.toRow][move.toCol] = originalPiece;
                        return move;
                    }
                    
                    board[move.fromRow][move.fromCol] = movingPiece;
                    board[move.toRow][move.toCol] = originalPiece;
                }
            }
            
            // Second priority: Look for checkmate in 1
            for (const move of moves) {
                const originalPiece = board[move.toRow][move.toCol];
                const movingPiece = board[move.fromRow][move.fromCol];
                board[move.toRow][move.toCol] = movingPiece;
                board[move.fromRow][move.fromCol] = '';
                
                if (isKingInCheck(board, enemyColor)) {
                    const enemyMoves = getAllPossibleMoves(enemyColor);
                    if (enemyMoves.length === 0) {
                        // This is checkmate!
                        board[move.fromRow][move.fromCol] = movingPiece;
                        board[move.toRow][move.toCol] = originalPiece;
                        return move;
                    }
                }
                
                board[move.fromRow][move.fromCol] = movingPiece;
                board[move.toRow][move.toCol] = originalPiece;
            }
            
            // Third priority: Capture enemy queen if possible
            const enemyQueen = enemyColor === 'white' ? '‚ôï' : '‚ôõ';
            for (const move of moves) {
                if (board[move.toRow][move.toCol] === enemyQueen) {
                    // Make sure it's a legal capture
                    const originalPiece = board[move.toRow][move.toCol];
                    const movingPiece = board[move.fromRow][move.fromCol];
                    board[move.toRow][move.toCol] = movingPiece;
                    board[move.fromRow][move.fromCol] = '';
                    
                    const safe = !isKingInCheck(board, player);
                    
                    board[move.fromRow][move.fromCol] = movingPiece;
                    board[move.toRow][move.toCol] = originalPiece;
                    
                    if (safe) return move;
                }
            }
            
            return null; // No emergency move needed
        }        // Critical safety functions to prevent basic blunders
        function canEnemyCheckmateNext(enemyColor) {
            const enemyMoves = getAllPossibleMoves(enemyColor);
            
            for (const move of enemyMoves) {
                // Try the enemy move
                const originalPiece = board[move.toRow][move.toCol];
                const movingPiece = board[move.fromRow][move.fromCol];
                board[move.toRow][move.toCol] = movingPiece;
                board[move.fromRow][move.fromCol] = '';
                
                // Check if this puts us in checkmate
                const ourColor = enemyColor === 'white' ? 'black' : 'white';
                if (isKingInCheck(board, ourColor)) {
                    const ourMoves = getAllPossibleMoves(ourColor);
                    if (ourMoves.length === 0) {
                        // This is checkmate!
                        board[move.fromRow][move.fromCol] = movingPiece;
                        board[move.toRow][move.toCol] = originalPiece;
                        return true;
                    }
                }
                
                // Undo the move
                board[move.fromRow][move.fromCol] = movingPiece;
                board[move.toRow][move.toCol] = originalPiece;
            }
            
            return false;
        }

        function canEnemyCaptureQueen(enemyColor) {
            const ourColor = enemyColor === 'white' ? 'black' : 'white';
            const ourQueen = ourColor === 'white' ? '‚ôï' : '‚ôõ';
            
            // Find our queen
            let queenRow = -1, queenCol = -1;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === ourQueen) {
                        queenRow = row;
                        queenCol = col;
                        break;
                    }
                }
                if (queenRow !== -1) break;
            }
            
            if (queenRow === -1) return false; // No queen to capture
            
            // Check if enemy can capture our queen
            const enemyMoves = getAllPossibleMoves(enemyColor);
            for (const move of enemyMoves) {
                if (move.toRow === queenRow && move.toCol === queenCol) {
                    return true;
                }
            }
            
            return false;
        }        // New function focused on immediate capture opportunities
        function evaluateImmediateThreats(player) {
            let threats = 0;
            const enemy = player === 'white' ? 'black' : 'white';
            
            // Look for pieces we can capture next move
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        
                        // Check all squares this piece can attack
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                const targetPiece = board[toRow][toCol];
                                
                                if (targetPiece && isPlayerPiece(targetPiece, enemy)) {
                                    const tempCurrentPlayer = currentPlayer;
                                    currentPlayer = player;
                                    
                                    if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                        const captureValue = getPieceValue(targetPiece);
                                        
                                        // Check if it's a safe capture
                                        board[toRow][toCol] = piece;
                                        board[fromRow][fromCol] = '';
                                        
                                        const attackers = getAttackers(toRow, toCol, enemy);
                                        
                                        if (attackers.length === 0) {
                                            // Safe capture - big bonus!
                                            threats += captureValue * 0.8;
                                        } else {
                                            // Risky capture - smaller bonus
                                            threats += captureValue * 0.3;
                                        }
                                        
                                        // Restore board
                                        board[fromRow][fromCol] = piece;
                                        board[toRow][toCol] = targetPiece;
                                    }
                                    
                                    currentPlayer = tempCurrentPlayer;
                                }
                            }
                        }
                    }
                }
            }
            
            return threats;
        }        function makeAIMove() {
            if (gameOver) return;
            
            document.getElementById('thinking').style.display = 'block';
            
            setTimeout(() => {
                const aiPlayer = humanPlayer === 'white' ? 'black' : 'white';
                let bestMove = null;
                
                // Use opening book for first 5 moves only (reduced)
                if (moveCount <= 3) {
                    try {
                        bestMove = getOpeningMove(aiPlayer);
                    } catch (e) {
                        console.log("Opening book failed, using minimax");
                        bestMove = null;
                    }
                }
                
                // If no opening move found, use minimax with timeout protection
                if (!bestMove) {
                    try {
                        bestMove = getBestMoveMinMax(aiPlayer, Math.min(aiDepth, 3)); // Reduced depth
                    } catch (e) {
                        console.log("Minimax failed, using random move");
                        const allMoves = getAllPossibleMoves(aiPlayer);
                        if (allMoves.length > 0) {
                            bestMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                        }
                    }
                }
                
                // Final fallback - just pick any legal move
                if (!bestMove) {
                    const allMoves = getAllPossibleMoves(aiPlayer);
                    if (allMoves.length > 0) {
                        bestMove = allMoves[0];
                    }
                }
                
                if (bestMove) {
                    makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    switchPlayer();
                    updateStatus();
                }
                document.getElementById('thinking').style.display = 'none';
            }, 800); // Reduced thinking time
        }
    </script>
</body>
</html>
