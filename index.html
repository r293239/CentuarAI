<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI - Advanced & Fast</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 700px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .info-section {
            margin: 5px;
        }

        #chessboard {
            width: 480px;
            height: 480px;
            margin: 20px auto;
            border: 2px solid #000;
            position: relative;
        }

        .square {
            width: 60px;
            height: 60px;
            float: left;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            user-select: none;
        }

        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        
        .square:hover {
            opacity: 0.8;
        }
        
        .selected {
            background-color: #87CEEB !important;
            box-shadow: inset 0 0 10px rgba(0,0,255,0.5);
        }
        
        .possible-move {
            background-color: #90EE90 !important;
        }

        .last-move {
            background-color: #FFE4B5 !important;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background: #5a6fd8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            background: #f9f9f9;
        }

        .thinking {
            text-align: center;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }

        .move-history {
            max-height: 150px;
            overflow-y: auto;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }

        .evaluation {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: #e8f4fd;
            border-radius: 5px;
            font-weight: bold;
        }

        .difficulty-controls {
            text-align: center;
            margin: 15px 0;
        }

        .difficulty-controls label {
            font-weight: bold;
            margin-right: 10px;
        }

        .difficulty-controls select {
            padding: 5px;
            font-size: 14px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .performance-info {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: #f0f8ff;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Advanced Chess AI - Optimized ‚ôõ</h1>
        
        <div class="game-info">
            <div class="info-section">
                <strong>Current Player:</strong> <span id="current-player">White</span>
            </div>
            <div class="info-section">
                <strong>You are:</strong> <span id="player-side">White</span>
            </div>
            <div class="info-section">
                <strong>Move:</strong> <span id="move-counter">1</span>
            </div>
        </div>

        <div class="difficulty-controls">
            <label for="difficulty">AI Difficulty:</label>
            <select id="difficulty" onchange="changeDifficulty()">
                <option value="1">Beginner (Depth 1)</option>
                <option value="2">Easy (Depth 2)</option>
                <option value="3">Normal (Depth 3)</option>
                <option value="4" selected>Hard (Depth 4)</option>
                <option value="5">Expert (Depth 5)</option>
                <option value="6">Master (Depth 6)</option>
            </select>
        </div>

        <div class="evaluation" id="evaluation">Position evaluation: 0.00</div>
        <div class="performance-info" id="performance">Ready to play</div>
        
        <div id="status" class="status">White to move</div>
        <div id="thinking" class="thinking" style="display: none;">ü§î AI is calculating... (depth: <span id="search-depth">4</span>)</div>
        
        <div id="chessboard"></div>
        
        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="undoMove()" id="undo-btn">Undo Move</button>
            <button onclick="switchSides()">Switch Sides</button>
            <button onclick="analyzePosition()" id="analyze-btn">Analyze</button>
        </div>
        
        <div class="move-history">
            <strong>Move History:</strong>
            <div id="move-list"></div>
        </div>
    </div>

    <script>
        // Enhanced chess board with better data structures
        let board = [
            ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
            ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
            ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
        ];

        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameHistory = [];
        let moveHistory = [];
        let gameOver = false;
        let humanPlayer = 'white';
        let aiDepth = 4;
        let moveCount = 1;
        let halfMoveCount = 0;
        let lastMove = null;
        let isAnalyzing = false;
        
        // Enhanced castling and game state tracking
        let castlingRights = {
            whiteKingside: true,
            whiteQueenside: true,
            blackKingside: true,
            blackQueenside: true
        };
        
        let enPassantTarget = null;
        let repetitionHistory = new Map();

        // Performance tracking
        let searchStartTime = 0;
        let nodesSearched = 0;
        let transpositionTable = new Map();
        let killerMoves = [];
        let historyTable = {};

        // Piece value mappings
        const pieceMap = {
            '‚ôú': 'r', '‚ôû': 'n', '‚ôù': 'b', '‚ôõ': 'q', '‚ôö': 'k', '‚ôü': 'p',
            '‚ôñ': 'R', '‚ôò': 'N', '‚ôó': 'B', '‚ôï': 'Q', '‚ôî': 'K', '‚ôô': 'P'
        };

        const symbolMap = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
        };

        // Piece values for quick evaluation
        const PIECE_VALUES = {
            '‚ôô': 100, '‚ôò': 320, '‚ôó': 330, '‚ôñ': 500, '‚ôï': 900, '‚ôî': 20000,
            '‚ôü': 100, '‚ôû': 320, '‚ôù': 330, '‚ôú': 500, '‚ôõ': 900, '‚ôö': 20000,
            '': 0
        };

        // Simplified piece-square tables (only for key pieces)
        const PST = {
            'P': [
                [0,0,0,0,0,0,0,0], [50,50,50,50,50,50,50,50], [10,10,20,30,30,20,10,10], [5,5,10,27,27,10,5,5],
                [0,0,0,25,25,0,0,0], [5,-5,-10,0,0,-10,-5,5], [5,10,10,-25,-25,10,10,5], [0,0,0,0,0,0,0,0]
            ],
            'N': [
                [-50,-40,-30,-30,-30,-30,-40,-50], [-40,-20,0,0,0,0,-20,-40], [-30,0,10,15,15,10,0,-30], [-30,5,15,20,20,15,5,-30],
                [-30,0,15,20,20,15,0,-30], [-30,5,10,15,15,10,5,-30], [-40,-20,0,5,5,0,-20,-40], [-50,-40,-30,-30,-30,-30,-40,-50]
            ]
        };

        // Enhanced opening book with more variations
        const openingBook = {
            "": [
                { move: "e2-e4", weight: 35 },
                { move: "d2-d4", weight: 30 },
                { move: "Ng1-f3", weight: 20 },
                { move: "c2-c4", weight: 15 }
            ],
            "e7-e5": [
                { move: "Ng1-f3", weight: 45 },
                { move: "Bf1-c4", weight: 25 },
                { move: "f2-f4", weight: 15 },
                { move: "Nb1-c3", weight: 15 }
            ],
            "e7-e5,Nb8-c6": [
                { move: "Bf1-c4", weight: 30 },
                { move: "Bf1-b5", weight: 25 },
                { move: "d2-d4", weight: 25 },
                { move: "Nb1-c3", weight: 20 }
            ],
            "d7-d5": [
                { move: "d2-d4", weight: 40 },
                { move: "c2-c4", weight: 30 },
                { move: "Ng1-f3", weight: 30 }
            ],
            "Ng8-f6": [
                { move: "d2-d4", weight: 35 },
                { move: "c2-c4", weight: 25 },
                { move: "Ng1-f3", weight: 25 },
                { move: "g2-g3", weight: 15 }
            ]
        };

        function createBoard() {
            const boardElement = document.getElementById('chessboard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.id = `square-${row}-${col}`;
                    
                    if ((row + col) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }
                    
                    // Highlight last move
                    if (lastMove && 
                        ((lastMove.fromRow === row && lastMove.fromCol === col) ||
                         (lastMove.toRow === row && lastMove.toCol === col))) {
                        square.classList.add('last-move');
                    }
                    
                    square.textContent = board[row][col];
                    square.onclick = () => handleSquareClick(row, col);
                    
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameOver || currentPlayer !== humanPlayer || isAnalyzing) return;
            
            const square = document.getElementById(`square-${row}-${col}`);
            const piece = board[row][col];
            
            if (selectedSquare) {
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;
                
                if (fromRow === row && fromCol === col) {
                    clearSelection();
                    return;
                }
                
                if (isValidMove(fromRow, fromCol, row, col)) {
                    makeMove(fromRow, fromCol, row, col);
                    clearSelection();
                    switchPlayer();
                    updateStatus();
                    updateEvaluation();
                    
                    if (!gameOver && currentPlayer !== humanPlayer) {
                        setTimeout(makeAIMove, 200);
                    }
                } else {
                    if (piece && isPlayerPiece(piece, currentPlayer)) {
                        selectSquare(row, col);
                    } else {
                        clearSelection();
                    }
                }
            } else {
                if (piece && isPlayerPiece(piece, currentPlayer)) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            clearSelection();
            selectedSquare = { row, col };
            document.getElementById(`square-${row}-${col}`).classList.add('selected');
            showPossibleMoves(row, col);
        }

        function clearSelection() {
            selectedSquare = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'possible-move');
            });
            createBoard();
        }

        function showPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.getElementById(`square-${r}-${c}`);
                        square.classList.add('possible-move');
                    }
                }
            }
        }

        function isPlayerPiece(piece, player) {
            if (!piece) return false;
            const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
            const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
            
            if (player === 'white') {
                return whitePieces.includes(piece);
            } else {
                return blackPieces.includes(piece);
            }
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            if (!piece) return false;
            if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) return false;
            
            // Castling check
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                return canCastle(fromRow, fromCol, toRow, toCol);
            }
            
            // En passant check
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(toCol - fromCol) === 1 && !targetPiece && enPassantTarget) {
                if (toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                    return true;
                }
            }
            
            const pieceCode = pieceMap[piece];
            if (!isValidPieceMove(pieceCode, fromRow, fromCol, toRow, toCol)) return false;
            
            // Check if move leaves king in check
            return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol);
        }

        function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const originalTarget = board[toRow][toCol];
            
            // Handle en passant capture
            let capturedPawnRow = null;
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = '';
            }
            
            // Make temporary move
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            const inCheck = isKingInCheck(board, currentPlayer);
            
            // Restore board
            board[fromRow][fromCol] = piece;
            board[toRow][toCol] = originalTarget;
            
            if (capturedPawnRow !== null) {
                const capturedPawn = piece === '‚ôô' ? '‚ôü' : '‚ôô';
                board[capturedPawnRow][toCol] = capturedPawn;
            }
            
            return inCheck;
        }

        function canCastle(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const isWhite = piece === '‚ôî';
            const isKingside = toCol > fromCol;
            
            // Check castling rights
            if (isWhite) {
                if (isKingside && !castlingRights.whiteKingside) return false;
                if (!isKingside && !castlingRights.whiteQueenside) return false;
            } else {
                if (isKingside && !castlingRights.blackKingside) return false;
                if (!isKingside && !castlingRights.blackQueenside) return false;
            }
            
            // King must not be in check
            if (isKingInCheck(board, currentPlayer)) return false;
            
            // Check if rook is in place
            const rookCol = isKingside ? 7 : 0;
            const expectedRook = isWhite ? '‚ôñ' : '‚ôú';
            if (board[fromRow][rookCol] !== expectedRook) return false;
            
            // Check path is clear
            const start = Math.min(fromCol, rookCol) + 1;
            const end = Math.max(fromCol, rookCol);
            
            for (let col = start; col < end; col++) {
                if (board[fromRow][col] !== '') return false;
            }
            
            // Check king doesn't pass through or end in check
            const direction = isKingside ? 1 : -1;
            for (let col = fromCol; col !== toCol + direction; col += direction) {
                board[fromRow][col] = '';
                board[fromRow][col + direction] = piece;
                
                if (isKingInCheck(board, currentPlayer)) {
                    // Restore
                    board[fromRow][fromCol] = piece;
                    board[fromRow][col + direction] = '';
                    return false;
                }
            }
            
            // Restore king position
            board[fromRow][fromCol] = piece;
            board[fromRow][toCol] = '';
            
            return true;
        }

        function isValidPieceMove(piece, fromRow, fromCol, toRow, toCol) {
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (piece.toLowerCase()) {
                case 'p':
                    const direction = piece === 'P' ? -1 : 1;
                    const startRow = piece === 'P' ? 6 : 1;
                    
                    if (dx === 0) {
                        // Forward moves
                        if (dy === direction && !board[toRow][toCol]) return true;
                        if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol]) return true;
                    } else if (absDx === 1 && dy === direction && board[toRow][toCol]) {
                        // Diagonal captures
                        return true;
                    }
                    return false;
                    
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    
                case 'b':
                    return absDx === absDy && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'k':
                    return absDx <= 1 && absDy <= 1;
                    
                default:
                    return false;
            }
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Store game state for undo
            gameHistory.push({
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                moveHistory: [...moveHistory],
                moveCount: moveCount,
                halfMoveCount: halfMoveCount,
                castlingRights: { ...castlingRights },
                enPassantTarget: enPassantTarget,
                lastMove: lastMove
            });
            
            lastMove = { fromRow, fromCol, toRow, toCol };
            
            // Handle castling
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const rook = board[fromRow][rookFromCol];
                
                board[fromRow][rookToCol] = rook;
                board[fromRow][rookFromCol] = '';
            }
            
            // Handle en passant
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                const capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = '';
            }
            
            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            // Handle pawn promotion
            if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                const promotedPiece = getPromotionPiece(piece);
                board[toRow][toCol] = promotedPiece;
            }
            
            // Update game state
            updateCastlingRights(piece, fromRow, fromCol, toRow, toCol);
            updateEnPassantTarget(piece, fromRow, toRow, toCol);
            updateHalfMoveClock(piece, capturedPiece);
            
            if (currentPlayer === 'black') {
                moveCount++;
            }
            
            // Record move
            const moveNotation = getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece);
            moveHistory.push(moveNotation);
            updateMoveHistory();
            
            createBoard();
        }

        function getPromotionPiece(pawn) {
            if (currentPlayer !== humanPlayer) {
                return pawn === '‚ôô' ? '‚ôï' : '‚ôõ';
            }
            
            const isWhite = pawn === '‚ôô';
            const pieces = isWhite ? ['‚ôï', '‚ôñ', '‚ôó', '‚ôò'] : ['‚ôõ', '‚ôú', '‚ôù', '‚ôû'];
            
            let choice = 0;
            const userChoice = prompt(`Promote pawn to:\n0 - Queen\n1 - Rook\n2 - Bishop\n3 - Knight`, '0');
            if (userChoice !== null) {
                const num = parseInt(userChoice);
                if (num >= 0 && num <= 3) {
                    choice = num;
                }
            }
            
            return pieces[choice];
        }

        function updateCastlingRights(piece, fromRow, fromCol, toRow, toCol) {
            if (piece === '‚ôî') {
                castlingRights.whiteKingside = false;
                castlingRights.whiteQueenside = false;
            } else if (piece === '‚ôö') {
                castlingRights.blackKingside = false;
                castlingRights.blackQueenside = false;
            }
            
            // Rook moves
            if (piece === '‚ôñ' && fromRow === 7) {
                if (fromCol === 0) castlingRights.whiteQueenside = false;
                if (fromCol === 7) castlingRights.whiteKingside = false;
            }
            if (piece === '‚ôú' && fromRow === 0) {
                if (fromCol === 0) castlingRights.blackQueenside = false;
                if (fromCol === 7) castlingRights.blackKingside = false;
            }
            
            // Rook captures
            if (toRow === 7 && toCol === 0) castlingRights.whiteQueenside = false;
            if (toRow === 7 && toCol === 7) castlingRights.whiteKingside = false;
            if (toRow === 0 && toCol === 0) castlingRights.blackQueenside = false;
            if (toRow === 0 && toCol === 7) castlingRights.blackKingside = false;
        }

        function updateEnPassantTarget(piece, fromRow, toRow, toCol) {
            enPassantTarget = null;
            
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {
                    row: piece === '‚ôô' ? fromRow - 1 : fromRow + 1,
                    col: toCol
                };
            }
        }

        function updateHalfMoveClock(piece, capturedPiece) {
            if ((piece === '‚ôô' || piece === '‚ôü') || capturedPiece) {
                halfMoveCount = 0;
            } else {
                halfMoveCount++;
            }
        }

        function getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
            
            const fromSquare = files[fromCol] + ranks[fromRow];
            const toSquare = files[toCol] + ranks[toRow];
            
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                return toCol > fromCol ? 'O-O' : 'O-O-O';
            }
            
            let notation = '';
            
            if (piece === '‚ôü' || piece === '‚ôô') {
                if (capturedPiece || (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col)) {
                    notation = files[fromCol] + 'x' + toSquare;
                } else {
                    notation = toSquare;
                }
                
                if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                    const promotedPiece = board[toRow][toCol];
                    const promotionSymbol = promotedPiece === '‚ôï' || promotedPiece === '‚ôõ' ? 'Q' :
                                           promotedPiece === '‚ôñ' || promotedPiece === '‚ôú' ? 'R' :
                                           promotedPiece === '‚ôó' || promotedPiece === '‚ôù' ? 'B' : 'N';
                    notation += '=' + promotionSymbol;
                }
            } else {
                const pieceChar = piece === '‚ôû' || piece === '‚ôò' ? 'N' :
                                 piece === '‚ôù' || piece === '‚ôó' ? 'B' :
                                 piece === '‚ôú' || piece === '‚ôñ' ? 'R' :
                                 piece === '‚ôõ' || piece === '‚ôï' ? 'Q' :
                                 piece === '‚ôö' || piece === '‚ôî' ? 'K' : '';
                
                notation = pieceChar + (capturedPiece ? 'x' : '') + toSquare;
            }
            
            return notation;
        }

        function isKingInCheck(testBoard, player) {
            const kingSymbol = player === 'white' ? '‚ôî' : '‚ôö';
            let kingRow = -1, kingCol = -1;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (testBoard[row][col] === kingSymbol) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            if (kingRow === -1) return false;
            
            return isSquareAttacked(testBoard, kingRow, kingCol, player === 'white' ? 'black' : 'white');
        }

        function isSquareAttacked(testBoard, targetRow, targetCol, attackerColor) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = testBoard[row][col];
                    if (piece && isPlayerPiece(piece, attackerColor)) {
                        const pieceCode = pieceMap[piece];
                        if (canPieceAttack(pieceCode, row, col, targetRow, targetCol, testBoard)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canPieceAttack(piece, fromRow, fromCol, toRow, toCol, testBoard) {
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (piece.toLowerCase()) {
                case 'p':
                    const direction = piece === 'P' ? -1 : 1;
                    return absDx === 1 && dy === direction;
                    
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    
                case 'b':
                    return absDx === absDy && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'k':
                    return absDx <= 1 && absDy <= 1;
                    
                default:
                    return false;
            }
        }

        function isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (testBoard[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
            document.getElementById('move-counter').textContent = moveCount;
        }

        // OPTIMIZED AI ENGINE
        function makeAIMove() {
            if (gameOver) return;
            
            document.getElementById('thinking').style.display = 'block';
            document.getElementById('search-depth').textContent = aiDepth;
            
            // Clear optimization tables periodically
            if (transpositionTable.size > 10000) {
                transpositionTable.clear();
            }
            
            searchStartTime = performance.now();
            nodesSearched = 0;
            
            setTimeout(() => {
                const aiPlayer = currentPlayer;
                let bestMove = null;
                
                try {
                    // Check for book moves first
                    if (moveCount <= 6 && moveHistory.length <= 12) {
                        bestMove = getOpeningMove();
                    }
                    
                    // Use optimized minimax search
                    if (!bestMove) {
                        bestMove = getBestMoveOptimized(aiPlayer, aiDepth);
                    }
                    
                    // Fallback to simple move
                    if (!bestMove) {
                        const moves = getAllPossibleMovesOptimized(aiPlayer);
                        bestMove = moves[0];
                    }
                    
                    if (bestMove) {
                        makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                        switchPlayer();
                        updateStatus();
                        updateEvaluation();
                    }
                } catch (e) {
                    console.error("AI error:", e);
                    const moves = getAllPossibleMovesOptimized(aiPlayer);
                    if (moves.length > 0) {
                        const fallbackMove = moves[0];
                        makeMove(fallbackMove.fromRow, fallbackMove.fromCol, fallbackMove.toRow, fallbackMove.toCol);
                        switchPlayer();
                        updateStatus();
                        updateEvaluation();
                    }
                }
                
                const searchTime = performance.now() - searchStartTime;
                document.getElementById('performance').textContent = 
                    `Search: ${Math.round(searchTime)}ms, Nodes: ${nodesSearched}, NPS: ${Math.round(nodesSearched / (searchTime / 1000))}`;
                
                document.getElementById('thinking').style.display = 'none';
            }, 150);
        }

        function getBestMoveOptimized(player, depth) {
            const moves = getAllPossibleMovesOptimized(player);
            if (moves.length === 0) return null;
            
            // Enhanced move ordering
            moves.sort((a, b) => orderMovesOptimized(b, player) - orderMovesOptimized(a, player));
            
            let bestMove = null;
            let bestScore = player === humanPlayer ? Infinity : -Infinity;
            let alpha = -Infinity;
            let beta = Infinity;
            
            for (const move of moves) {
                makeTemporaryMoveOptimized(move);
                
                const score = minimaxOptimized(depth - 1, 
                    player === 'white' ? 'black' : 'white', 
                    alpha, beta, player !== humanPlayer, depth);
                
                undoTemporaryMoveOptimized();
                
                if ((player !== humanPlayer && score > bestScore) || 
                    (player === humanPlayer && score < bestScore)) {
                    bestScore = score;
                    bestMove = move;
                }
                
                if (player !== humanPlayer) {
                    alpha = Math.max(alpha, score);
                } else {
                    beta = Math.min(beta, score);
                }
                
                if (beta <= alpha) break; // Alpha-beta pruning
            }
            
            return bestMove;
        }

        function orderMovesOptimized(move, player) {
            let score = 0;
            const piece = board[move.fromRow][move.fromCol];
            const target = board[move.toRow][move.toCol];
            
            // Prioritize captures with MVV-LVA
            if (target) {
                const targetValue = PIECE_VALUES[target];
                const pieceValue = PIECE_VALUES[piece];
                score += (targetValue * 10 - pieceValue) * 100;
            }
            
            // Check for en passant capture
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                move.toRow === enPassantTarget.row && move.toCol === enPassantTarget.col) {
                score += 100 * 100; // Value of captured pawn
            }
            
            // Killer moves heuristic
            const moveKey = `${move.fromRow}${move.fromCol}${move.toRow}${move.toCol}`;
            if (killerMoves.includes(moveKey)) {
                score += 9000;
            }
            
            // History heuristic
            if (historyTable[moveKey]) {
                score += historyTable[moveKey];
            }
            
            // Prioritize central squares
            const centerBonus = getCenterControlBonus(move.toRow, move.toCol);
            score += centerBonus * 10;
            
            // Piece development in opening
            if (moveCount < 10) {
                const pieceType = piece.toLowerCase();
                if (pieceType === '‚ôû' || pieceType === '‚ôò' || pieceType === '‚ôù' || pieceType === '‚ôó') {
                    const backRank = isPlayerPiece(piece, 'white') ? 7 : 0;
                    if (move.fromRow === backRank) {
                        score += 50;
                    }
                }
            }
            
            return score;
        }

        function getCenterControlBonus(row, col) {
            const centerDistance = Math.abs(row - 3.5) + Math.abs(col - 3.5);
            return Math.max(0, 7 - centerDistance);
        }

        // Optimized move stack for faster temporary moves
        let tempMoveStack = [];

        function makeTemporaryMoveOptimized(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            
            // Handle en passant capture
            let enPassantCapture = null;
            let enPassantCaptureRow = null;
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                move.toRow === enPassantTarget.row && move.toCol === enPassantTarget.col) {
                enPassantCaptureRow = piece === '‚ôô' ? move.toRow + 1 : move.toRow - 1;
                enPassantCapture = board[enPassantCaptureRow][move.toCol];
                board[enPassantCaptureRow][move.toCol] = '';
            }
            
            tempMoveStack.push({
                move: move,
                piece: piece,
                capturedPiece: capturedPiece,
                enPassantCapture: enPassantCapture,
                enPassantCaptureRow: enPassantCaptureRow,
                oldEnPassantTarget: enPassantTarget,
                oldCastlingRights: { ...castlingRights },
                oldHalfMoveCount: halfMoveCount
            });
            
            // Make move
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = '';
            
            // Quick castling rights update
            if (piece === '‚ôî') {
                castlingRights.whiteKingside = false;
                castlingRights.whiteQueenside = false;
            } else if (piece === '‚ôö') {
                castlingRights.blackKingside = false;
                castlingRights.blackQueenside = false;
            }
            
            // Quick en passant update
            enPassantTarget = null;
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(move.toRow - move.fromRow) === 2) {
                enPassantTarget = {
                    row: piece === '‚ôô' ? move.fromRow - 1 : move.fromRow + 1,
                    col: move.toCol
                };
            }
            
            // Update half move clock
            if ((piece === '‚ôô' || piece === '‚ôü') || capturedPiece || enPassantCapture) {
                halfMoveCount = 0;
            } else {
                halfMoveCount++;
            }
        }

        function undoTemporaryMoveOptimized() {
            const moveData = tempMoveStack.pop();
            
            // Restore piece positions
            board[moveData.move.fromRow][moveData.move.fromCol] = moveData.piece;
            board[moveData.move.toRow][moveData.move.toCol] = moveData.capturedPiece;
            
            // Restore en passant capture
            if (moveData.enPassantCapture && moveData.enPassantCaptureRow !== null) {
                board[moveData.enPassantCaptureRow][moveData.move.toCol] = moveData.enPassantCapture;
            }
            
            // Restore game state
            enPassantTarget = moveData.oldEnPassantTarget;
            castlingRights = moveData.oldCastlingRights;
            halfMoveCount = moveData.oldHalfMoveCount;
        }

        function minimaxOptimized(depth, player, alpha, beta, maximizing, originalDepth) {
            nodesSearched++;
            
            // Check transposition table
            const boardHash = getBoardHash();
            const ttEntry = transpositionTable.get(boardHash);
            if (ttEntry && ttEntry.depth >= depth) {
                if (ttEntry.flag === 'exact') return ttEntry.score;
                if (ttEntry.flag === 'alpha' && ttEntry.score <= alpha) return alpha;
                if (ttEntry.flag === 'beta' && ttEntry.score >= beta) return beta;
            }
            
            if (depth === 0) {
                return quiescenceSearchOptimized(player, alpha, beta, maximizing, 4);
            }
            
            const moves = getAllPossibleMovesOptimized(player);
            
            if (moves.length === 0) {
                if (isKingInCheck(board, player)) {
                    return maximizing ? -10000 + (originalDepth - depth) : 10000 - (originalDepth - depth);
                }
                return 0; // Stalemate
            }
            
            // Check for draw by repetition or 50-move rule
            if (halfMoveCount >= 100) return 0;
            
            // Sort moves
            moves.sort((a, b) => orderMovesOptimized(b, player) - orderMovesOptimized(a, player));
            
            const originalAlpha = alpha;
            let bestScore = maximizing ? -Infinity : Infinity;
            let bestMove = null;
            
            for (const move of moves) {
                makeTemporaryMoveOptimized(move);
                const score = minimaxOptimized(depth - 1, player === 'white' ? 'black' : 'white', alpha, beta, !maximizing, originalDepth);
                undoTemporaryMoveOptimized();
                
                if (maximizing) {
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, score);
                } else {
                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, score);
                }
                
                if (beta <= alpha) {
                    // Store killer move
                    const moveKey = `${move.fromRow}${move.fromCol}${move.toRow}${move.toCol}`;
                    if (!killerMoves.includes(moveKey)) {
                        killerMoves.unshift(moveKey);
                        if (killerMoves.length > 4) killerMoves.pop();
                    }
                    break;
                }
            }
            
            // Update history table for good moves
            if (bestMove && !board[bestMove.toRow][bestMove.toCol]) {
                const moveKey = `${bestMove.fromRow}${bestMove.fromCol}${bestMove.toRow}${bestMove.toCol}`;
                historyTable[moveKey] = (historyTable[moveKey] || 0) + depth * depth;
            }
            
            // Store in transposition table
            let flag = 'exact';
            if (bestScore <= originalAlpha) flag = 'alpha';
            else if (bestScore >= beta) flag = 'beta';
            
            transpositionTable.set(boardHash, {
                score: bestScore,
                depth: depth,
                flag: flag,
                move: bestMove
            });
            
            return bestScore;
        }

        function quiescenceSearchOptimized(player, alpha, beta, maximizing, depth) {
            nodesSearched++;
            
            if (depth <= 0) return evaluatePositionOptimized();
            
            const standPat = evaluatePositionOptimized();
            
            if (maximizing) {
                if (standPat >= beta) return beta;
                alpha = Math.max(alpha, standPat);
            } else {
                if (standPat <= alpha) return alpha;
                beta = Math.min(beta, standPat);
            }
            
            // Only search captures and checks
            const captures = getAllCapturesOptimized(player);
            captures.sort((a, b) => orderMovesOptimized(b, player) - orderMovesOptimized(a, player));
            
            for (const move of captures) {
                makeTemporaryMoveOptimized(move);
                const score = quiescenceSearchOptimized(player === 'white' ? 'black' : 'white', alpha, beta, !maximizing, depth - 1);
                undoTemporaryMoveOptimized();
                
                if (maximizing) {
                    if (score >= beta) return beta;
                    alpha = Math.max(alpha, score);
                } else {
                    if (score <= alpha) return alpha;
                    beta = Math.min(beta, score);
                }
            }
            
            return maximizing ? alpha : beta;
        }

        function getAllCapturesOptimized(player) {
            const captures = [];
            
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        // Quick capture check for different piece types
                        if (piece === '‚ôô' || piece === '‚ôü') {
                            // Pawn captures
                            const direction = piece === '‚ôô' ? -1 : 1;
                            for (let dc = -1; dc <= 1; dc += 2) {
                                const toRow = fromRow + direction;
                                const toCol = fromCol + dc;
                                if (toRow >= 0 && toRow <= 7 && toCol >= 0 && toCol <= 7) {
                                    if (board[toRow][toCol] && isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                        captures.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                    // En passant capture
                                    if (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                                        captures.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        } else {
                            // Other pieces - check all possible moves for captures
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (board[toRow][toCol] && isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                        const oldPlayer = currentPlayer;
                                        currentPlayer = player;
                                        if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                            captures.push({ fromRow, fromCol, toRow, toCol });
                                        }
                                        currentPlayer = oldPlayer;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return captures;
        }

        function getBoardHash() {
            let hash = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    hash += board[row][col] || '-';
                }
            }
            hash += currentPlayer + JSON.stringify(castlingRights) + JSON.stringify(enPassantTarget);
            return hash;
        }

        // OPTIMIZED POSITION EVALUATION
        function evaluatePositionOptimized() {
            let score = 0;
            let whiteKingRow = -1, whiteKingCol = -1;
            let blackKingRow = -1, blackKingCol = -1;
            let totalMaterial = 0;
            
            // Material count and piece-square tables in one pass
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = PIECE_VALUES[piece];
                        totalMaterial += Math.abs(value);
                        
                        if (isPlayerPiece(piece, 'white')) {
                            score += value;
                            if (piece === '‚ôî') { whiteKingRow = row; whiteKingCol = col; }
                        } else {
                            score -= value;
                            if (piece === '‚ôö') { blackKingRow = row; blackKingCol = col; }
                        }
                        
                        // Quick piece-square table lookup for key pieces
                        const pieceType = pieceMap[piece].toUpperCase();
                        if (PST[pieceType]) {
                            const adjustedRow = isPlayerPiece(piece, 'white') ? 7 - row : row;
                            const pstValue = PST[pieceType][adjustedRow][col] * 0.1;
                            score += isPlayerPiece(piece, 'white') ? pstValue : -pstValue;
                        }
                    }
                }
            }
            
            // Quick positional evaluation
            score += evaluateQuickPositional(whiteKingRow, whiteKingCol, blackKingRow, blackKingCol, totalMaterial);
            
            return humanPlayer === 'white' ? score : -score;
        }

        function evaluateQuickPositional(whiteKingRow, whiteKingCol, blackKingRow, blackKingCol, totalMaterial) {
            let score = 0;
            const isEndgame = totalMaterial < 2500; // Simple endgame detection
            
            // King safety in middlegame vs centralization in endgame
            if (whiteKingRow !== -1 && whiteKingCol !== -1) {
                if (isEndgame) {
                    // Centralize king in endgame
                    const centerDistance = Math.abs(whiteKingRow - 3.5) + Math.abs(whiteKingCol - 3.5);
                    score += (7 - centerDistance) * 10;
                } else {
                    // King safety in middlegame
                    if (whiteKingCol > 5 || whiteKingCol < 3) score += 20; // Castled bonus
                }
            }
            
            if (blackKingRow !== -1 && blackKingCol !== -1) {
                if (isEndgame) {
                    // Centralize king in endgame
                    const centerDistance = Math.abs(blackKingRow - 3.5) + Math.abs(blackKingCol - 3.5);
                    score -= (7 - centerDistance) * 10;
                } else {
                    // King safety in middlegame
                    if (blackKingCol > 5 || blackKingCol < 3) score -= 20; // Castled bonus
                }
            }
            
            // Quick pawn structure evaluation
            for (let col = 0; col < 8; col++) {
                let whitePawns = 0, blackPawns = 0;
                for (let row = 0; row < 8; row++) {
                    if (board[row][col] === '‚ôô') whitePawns++;
                    if (board[row][col] === '‚ôü') blackPawns++;
                }
                
                // Doubled pawns penalty
                if (whitePawns > 1) score -= 15 * (whitePawns - 1);
                if (blackPawns > 1) score += 15 * (blackPawns - 1);
            }
            
            return score;
        }

        function getAllPossibleMovesOptimized(player) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        // Generate moves based on piece type for better performance
                        const pieceCode = pieceMap[piece].toLowerCase();
                        const pieceMoves = generatePieceMoves(pieceCode, fromRow, fromCol, player);
                        moves.push(...pieceMoves);
                    }
                }
            }
            return moves;
        }

        function generatePieceMoves(pieceCode, fromRow, fromCol, player) {
            const moves = [];
            const oldPlayer = currentPlayer;
            currentPlayer = player;
            
            switch (pieceCode) {
                case 'p':
                    // Pawn moves - optimized
                    const direction = player === 'white' ? -1 : 1;
                    const startRow = player === 'white' ? 6 : 1;
                    
                    // Forward moves
                    if (fromRow + direction >= 0 && fromRow + direction <= 7 && !board[fromRow + direction][fromCol]) {
                        moves.push({ fromRow, fromCol, toRow: fromRow + direction, toCol: fromCol });
                        // Double move from start
                        if (fromRow === startRow && !board[fromRow + 2 * direction][fromCol]) {
                            moves.push({ fromRow, fromCol, toRow: fromRow + 2 * direction, toCol: fromCol });
                        }
                    }
                    
                    // Diagonal captures
                    for (let dc = -1; dc <= 1; dc += 2) {
                        const toRow = fromRow + direction;
                        const toCol = fromCol + dc;
                        if (toRow >= 0 && toRow <= 7 && toCol >= 0 && toCol <= 7) {
                            if (board[toRow][toCol] && isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                moves.push({ fromRow, fromCol, toRow, toCol });
                            }
                            // En passant
                            if (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                                moves.push({ fromRow, fromCol, toRow, toCol });
                            }
                        }
                    }
                    break;
                    
                case 'r':
                    // Rook moves
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if ((dr === 0) !== (dc === 0)) { // Only horizontal/vertical
                                for (let i = 1; i < 8; i++) {
                                    const toRow = fromRow + dr * i;
                                    const toCol = fromCol + dc * i;
                                    if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) break;
                                    
                                    if (board[toRow][toCol]) {
                                        if (isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                            moves.push({ fromRow, fromCol, toRow, toCol });
                                        }
                                        break;
                                    }
                                    moves.push({ fromRow, fromCol, toRow, toCol });
                                }
                            }
                        }
                    }
                    break;
                    
                case 'n':
                    // Knight moves
                    const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                    for (const [dr, dc] of knightMoves) {
                        const toRow = fromRow + dr;
                        const toCol = fromCol + dc;
                        if (toRow >= 0 && toRow <= 7 && toCol >= 0 && toCol <= 7) {
                            if (!board[toRow][toCol] || isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                moves.push({ fromRow, fromCol, toRow, toCol });
                            }
                        }
                    }
                    break;
                    
                case 'b':
                    // Bishop moves
                    for (let dr = -1; dr <= 1; dr += 2) {
                        for (let dc = -1; dc <= 1; dc += 2) {
                            for (let i = 1; i < 8; i++) {
                                const toRow = fromRow + dr * i;
                                const toCol = fromCol + dc * i;
                                if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) break;
                                
                                if (board[toRow][toCol]) {
                                    if (isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                    break;
                                }
                                moves.push({ fromRow, fromCol, toRow, toCol });
                            }
                        }
                    }
                    break;
                    
                case 'q':
                    // Queen moves (combination of rook and bishop)
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            for (let i = 1; i < 8; i++) {
                                const toRow = fromRow + dr * i;
                                const toCol = fromCol + dc * i;
                                if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) break;
                                
                                if (board[toRow][toCol]) {
                                    if (isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                    break;
                                }
                                moves.push({ fromRow, fromCol, toRow, toCol });
                            }
                        }
                    }
                    break;
                    
                case 'k':
                    // King moves
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const toRow = fromRow + dr;
                            const toCol = fromCol + dc;
                            if (toRow >= 0 && toRow <= 7 && toCol >= 0 && toCol <= 7) {
                                if (!board[toRow][toCol] || isPlayerPiece(board[toRow][toCol], player === 'white' ? 'black' : 'white')) {
                                    if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                    
                    // Castling
                    if (isValidMove(fromRow, fromCol, fromRow, fromCol + 2)) {
                        moves.push({ fromRow, fromCol, toRow: fromRow, toCol: fromCol + 2 });
                    }
                    if (isValidMove(fromRow, fromCol, fromRow, fromCol - 2)) {
                        moves.push({ fromRow, fromCol, toRow: fromRow, toCol: fromCol - 2 });
                    }
                    break;
            }
            
            currentPlayer = oldPlayer;
            return moves;
        }

        function getOpeningMove() {
            const gameState = buildGameStateString();
            
            if (openingBook[gameState]) {
                const possibleMoves = openingBook[gameState];
                const totalWeight = possibleMoves.reduce((sum, move) => sum + move.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const moveData of possibleMoves) {
                    random -= moveData.weight;
                    if (random <= 0) {
                        const parsedMove = parseOpeningMove(moveData.move);
                        if (parsedMove && isValidMove(parsedMove.fromRow, parsedMove.fromCol, parsedMove.toRow, parsedMove.toCol)) {
                            return parsedMove;
                        }
                    }
                }
            }
            
            return null;
        }

        function buildGameStateString() {
            return moveHistory.slice(-4).join(',');
        }

        function parseOpeningMove(moveStr) {
            try {
                const parts = moveStr.split('-');
                if (parts.length !== 2) return null;
                
                const fromSquare = parts[0];
                const toSquare = parts[1];
                
                let fromFile, fromRank, toFile, toRank;
                
                if (fromSquare.length === 3) {
                    fromFile = fromSquare.charCodeAt(1) - 97;
                    fromRank = 8 - parseInt(fromSquare.charAt(2));
                } else {
                    fromFile = fromSquare.charCodeAt(0) - 97;
                    fromRank = 8 - parseInt(fromSquare.charAt(1));
                }
                
                if (toSquare.length === 3) {
                    toFile = toSquare.charCodeAt(1) - 97;
                    toRank = 8 - parseInt(toSquare.charAt(2));
                } else {
                    toFile = toSquare.charCodeAt(0) - 97;
                    toRank = 8 - parseInt(toSquare.charAt(1));
                }
                
                if (fromFile >= 0 && fromFile <= 7 && fromRank >= 0 && fromRank <= 7 &&
                    toFile >= 0 && toFile <= 7 && toRank >= 0 && toRank <= 7) {
                    return {
                        fromRow: fromRank,
                        fromCol: fromFile,
                        toRow: toRank,
                        toCol: toFile
                    };
                }
            } catch (e) {
                console.log("Failed to parse move:", moveStr);
            }
            
            return null;
        }

        function updateStatus() {
            const statusElement = document.getElementById('status');
            const playerName = currentPlayer === 'white' ? 'White' : 'Black';
            
            if (isKingInCheck(board, currentPlayer)) {
                const moves = getAllPossibleMovesOptimized(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = `Checkmate! ${playerName === 'White' ? 'Black' : 'White'} wins!`;
                    statusElement.style.backgroundColor = '#ffcccb';
                    gameOver = true;
                } else {
                    statusElement.textContent = `${playerName} is in check!`;
                    statusElement.style.backgroundColor = '#ffe4b5';
                }
            } else {
                const moves = getAllPossibleMovesOptimized(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = 'Stalemate! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                } else if (halfMoveCount >= 100) {
                    statusElement.textContent = '50-move rule! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                } else if (isInsufficientMaterial()) {
                    statusElement.textContent = 'Insufficient material! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                } else {
                    statusElement.textContent = `${playerName} to move`;
                    statusElement.style.backgroundColor = '#f9f9f9';
                }
            }
        }

        function isInsufficientMaterial() {
            const pieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece !== '‚ôî' && piece !== '‚ôö') {
                        pieces.push(piece);
                    }
                }
            }
            
            if (pieces.length === 0) return true;
            if (pieces.length === 1) {
                const piece = pieces[0];
                return piece === '‚ôó' || piece === '‚ôù' || piece === '‚ôò' || piece === '‚ôû';
            }
            
            return false;
        }

        function updateEvaluation() {
            if (gameOver) return;
            
            const evaluation = evaluatePositionOptimized();
            const evalElement = document.getElementById('evaluation');
            
            let displayValue = (evaluation / 100).toFixed(2);
            let displayText = `Position evaluation: ${displayValue}`;
            
            if (Math.abs(evaluation) > 500) {
                if (evaluation > 0) {
                    displayText = `White is winning (+${Math.abs(parseFloat(displayValue))})`;
                } else {
                    displayText = `Black is winning (+${Math.abs(parseFloat(displayValue))})`;
                }
            } else if (Math.abs(evaluation) > 200) {
                if (evaluation > 0) {
                    displayText = `White has advantage (+${Math.abs(parseFloat(displayValue))})`;
                } else {
                    displayText = `Black has advantage (+${Math.abs(parseFloat(displayValue))})`;
                }
            } else if (Math.abs(evaluation) < 50) {
                displayText = `Position is equal (${displayValue})`;
            }
            
            evalElement.textContent = displayText;
            
            if (evaluation > 200) {
                evalElement.style.backgroundColor = '#e8f5e8';
            } else if (evaluation < -200) {
                evalElement.style.backgroundColor = '#ffe8e8';
            } else {
                evalElement.style.backgroundColor = '#e8f4fd';
            }
        }

        function updateMoveHistory() {
            const moveList = document.getElementById('move-list');
            let html = '';
            
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = moveHistory[i] || '';
                const blackMove = moveHistory[i + 1] || '';
                
                html += `${moveNumber}. ${whiteMove}`;
                if (blackMove) {
                    html += ` ${blackMove}`;
                }
                html += '<br>';
            }
            
            moveList.innerHTML = html;
            moveList.scrollTop = moveList.scrollHeight;
        }

        function changeDifficulty() {
            const difficulty = document.getElementById('difficulty').value;
            aiDepth = parseInt(difficulty);
            
            // Clear optimization tables when difficulty changes
            transpositionTable.clear();
            killerMoves = [];
            historyTable = {};
        }

        function analyzePosition() {
            if (isAnalyzing) return;
            
            isAnalyzing = true;
            const analyzeBtn = document.getElementById('analyze-btn');
            analyzeBtn.textContent = 'Analyzing...';
            analyzeBtn.disabled = true;
            
            setTimeout(() => {
                try {
                    searchStartTime = performance.now();
                    nodesSearched = 0;
                    
                    const evaluation = evaluatePositionOptimized();
                    const bestMove = getBestMoveOptimized(currentPlayer, Math.min(aiDepth + 1, 6));
                    
                    const searchTime = performance.now() - searchStartTime;
                    
                    let analysis = `Position evaluation: ${(evaluation / 100).toFixed(2)}\n`;
                    analysis += `Search time: ${Math.round(searchTime)}ms\n`;
                    analysis += `Nodes searched: ${nodesSearched}\n`;
                    
                    if (bestMove) {
                        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                        const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                        const from = files[bestMove.fromCol] + ranks[bestMove.fromRow];
                        const to = files[bestMove.toCol] + ranks[bestMove.toRow];
                        analysis += `Best move: ${from}-${to}`;
                    }
                    
                    alert(analysis);
                } catch (e) {
                    alert('Analysis failed: ' + e.message);
                }
                
                isAnalyzing = false;
                analyzeBtn.textContent = 'Analyze';
                analyzeBtn.disabled = false;
            }, 100);
        }

        function newGame() {
            board = [
                ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
            ];
            
            currentPlayer = 'white';
            selectedSquare = null;
            gameHistory = [];
            moveHistory = [];
            moveCount = 1;
            halfMoveCount = 0;
            gameOver = false;
            lastMove = null;
            tempMoveStack = [];
            
            // Clear optimization tables
            transpositionTable.clear();
            killerMoves = [];
            historyTable = {};
            
            castlingRights = {
                whiteKingside: true,
                whiteQueenside: true,
                blackKingside: true,
                blackQueenside: true
            };
            
            enPassantTarget = null;
            repetitionHistory.clear();
            
            document.getElementById('current-player').textContent = 'White';
            document.getElementById('player-side').textContent = humanPlayer === 'white' ? 'White' : 'Black';
            document.getElementById('move-counter').textContent = '1';
            document.getElementById('performance').textContent = 'Ready to play';
            
            createBoard();
            updateStatus();
            updateEvaluation();
            updateMoveHistory();
            
            if (currentPlayer !== humanPlayer) {
                setTimeout(makeAIMove, 500);
            }
        }

        function switchSides() {
            humanPlayer = humanPlayer === 'white' ? 'black' : 'white';
            document.getElementById('player-side').textContent = humanPlayer === 'white' ? 'White' : 'Black';
            
            clearSelection();
            
            if (!gameOver && currentPlayer !== humanPlayer && !isAnalyzing) {
                setTimeout(makeAIMove, 300);
            }
        }

        function undoMove() {
            if (gameHistory.length >= 1) {
                const lastState = gameHistory.pop();
                
                board = lastState.board;
                currentPlayer = lastState.currentPlayer;
                moveHistory = lastState.moveHistory;
                moveCount = lastState.moveCount;
                halfMoveCount = lastState.halfMoveCount;
                castlingRights = lastState.castlingRights;
                enPassantTarget = lastState.enPassantTarget;
                lastMove = lastState.lastMove;
                gameOver = false;
                
                // Clear search tables after undo
                transpositionTable.clear();
                
                document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
                document.getElementById('move-counter').textContent = moveCount;
                
                clearSelection();
                createBoard();
                updateStatus();
                updateEvaluation();
                updateMoveHistory();
            }
        }

        // Initialize the game
        createBoard();
        updateStatus();
        updateEvaluation();
        document.getElementById('player-side').textContent = 'White';
    </script>
<!-- TERMS POPUP + BOTTOM BAR (drop before </body>) -->
<style>
  /* Bottom bar */
  #consent-bar {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(20,20,20,0.95);
    color: #fff;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    font-size: 13px;
    padding: 12px 16px;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    gap: 8px;
    box-shadow: 0 -6px 24px rgba(0,0,0,0.5);
  }
  #consent-bar a {
    color: #9be7ff;
    text-decoration: underline;
    cursor: pointer;
  }
  #consent-bar button {
    margin-left: 12px;
    background: #0ea5a4;
    border: none;
    padding: 8px 12px;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
  }

  /* Modal backdrop */
  .terms-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100000;
    padding: 20px;
  }

  /* Modal dialog */
  .terms-modal {
    width: min(1100px, 98%);
    max-height: 90vh;
    background: linear-gradient(180deg,#0f172a,#071029);
    color: #e6eef8;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 12px 48px rgba(2,6,23,0.8);
    display: flex;
    flex-direction: column;
    border: 1px solid rgba(255,255,255,0.04);
  }

  .terms-header {
    padding: 16px 20px;
    background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .terms-title { font-size: 16px; font-weight:700; }
  .terms-close {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.06);
    color: #e6eef8;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
    font-weight:600;
  }

  .terms-body {
    padding: 18px;
    overflow: auto;
    line-height: 1.45;
    font-size: 13px;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
  }
  .terms-section { margin-bottom: 18px; }
  .terms-section h3 { margin: 8px 0; font-size: 14px; color:#cfefff; }
  .terms-actions {
    display:flex;
    gap:8px;
    padding: 12px 18px;
    border-top: 1px solid rgba(255,255,255,0.02);
    justify-content: flex-end;
    background: rgba(0,0,0,0.02);
  }
  .btn-accept {
    background: #10b981;
    border: none;
    color: white;
    padding: 10px 14px;
    border-radius: 8px;
    cursor:pointer;
    font-weight:700;
  }
  .btn-decline {
    background: transparent;
    color: #c9d7e6;
    border: 1px solid rgba(255,255,255,0.06);
    padding: 10px 14px;
    border-radius: 8px;
    cursor:pointer;
    font-weight:700;
  }

  /* small screens */
  @media (max-width:520px){
    #consent-bar { font-size:12px; padding:10px; }
    .terms-title { font-size: 15px; }
  }
</style>

<div id="consent-bar" role="status" aria-live="polite" style="display:none;">
  <div>
    By using this website you agree to the <a id="open-terms" href="#" aria-haspopup="dialog">Terms & Conditions</a>.
  </div>
  <button id="consent-accept-sm">Accept</button>
</div>

<div class="terms-backdrop" id="terms-backdrop" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="terms-title">
  <div class="terms-modal" role="document">
    <div class="terms-header">
      <div class="terms-title" id="terms-title">Centuar AI ‚Äî Terms & Conditions (Access-Only)</div>
      <div style="display:flex;gap:8px;">
        <button class="terms-close" id="terms-close">Close</button>
      </div>
    </div>

    <div class="terms-body" id="terms-body" tabindex="0">
      <!-- Long terms text -->
      <div class="terms-section">
        <h3>1. Acceptance</h3>
        <p>These Terms and Conditions ("Terms") govern your access to and use of the website hosted at <strong>https://centuarai.netlify.app</strong> ("Site"). By using or accessing the Site in any manner, you agree to be bound by these Terms. If you do not agree, immediately stop using the Site.</p>
      </div>

      <div class="terms-section">
        <h3>2. Access-Only License</h3>
        <p>The Site is provided under an access-only license. Your rights are strictly limited to interacting with and viewing the content presented in your browser while connected to the Site. You are expressly prohibited from copying, downloading, scraping, mirroring, or otherwise obtaining the underlying source code, assets, models, engine logic, or data from the Site by any means.</p>
      </div>

      <div class="terms-section">
        <h3>3. Prohibited Conduct</h3>
        <ul>
          <li>Do not attempt to access the server-side code, configuration files, or build pipeline.</li>
          <li>Do not decompile, reverse-engineer, disassemble, reproduce, or create derivative works from the Site or its responses.</li>
          <li>Do not host, redistribute, or publicly disclose any part of the Site content (including screenshots that reveal proprietary UI or logic) without explicit written permission.</li>
        </ul>
      </div>

      <div class="terms-section">
        <h3>4. Enforcement</h3>
        <p>Violations are grounds for immediate termination of access and may result in civil and/or criminal liability to the fullest extent permitted by law. The author reserves all rights, including the right to pursue takedown procedures (e.g., DMCA) and legal claims. Copyright in the Site content vests automatically in the author upon creation; registration of copyright is not required for protection.</p>
      </div>

      <div class="terms-section">
        <h3>5. Disclaimer & Limitation</h3>
        <p>The Site and all content are provided "as is" without warranties of any kind. The author is not liable for incidental or consequential damages arising from use of the Site, to the maximum extent permitted by applicable law.</p>
      </div>

      <div class="terms-section">
        <h3>6. Data Collection & Security</h3>
        <p>The Site may collect non-sensitive usage information to operate and maintain services. Any scraping or unauthorized data extraction is forbidden and will be treated as an abuse incident.</p>
      </div>

      <div class="terms-section">
        <h3>7. Severability & Changes</h3>
        <p>If any provision of these Terms is found invalid, remaining provisions continue in full force. The author may modify these Terms at any time; continued use after notice constitutes acceptance.</p>
      </div>

      <div class="terms-section">
        <h3>8. Contact</h3>
        <p>For permissions, licensing, or legal matters, contact the site owner at the address or email posted on the Site.</p>
      </div>

      <div class="terms-section">
        <h3>Appendix ‚Äî Example Restrictive Clauses</h3>
        <p>This appendix includes sample strong statements that reflect the enforcement approach used by the author (not an exhaustive list):</p>
        <ol>
          <li>"All code, runtime logic, build artifacts and UI assets are owned exclusively by the author and are protected by copyright and other intellectual property laws."</li>
          <li>"Unauthorized access, copying, or distribution will result in immediate takedown requests and may lead to civil litigation."</li>
          <li>"Your only license is to access the Site via the provided URL; any other use is a material breach of these Terms."</li>
        </ol>
      </div>

      <div style="height:18px;"></div>
    </div>

    <div class="terms-actions" role="toolbar" aria-label="Terms actions">
      <button class="btn-decline" id="btn-decline">Decline</button>
      <button class="btn-accept" id="btn-accept">I Agree</button>
    </div>
  </div>
</div>

<script>
  (function(){
    const BAR_KEY = 'centuar_terms_accepted_v1';
    const consentBar = document.getElementById('consent-bar');
    const openTerms = document.getElementById('open-terms');
    const backdrop = document.getElementById('terms-backdrop');
    const closeBtn = document.getElementById('terms-close');
    const acceptBtn = document.getElementById('btn-accept');
    const declineBtn = document.getElementById('btn-decline');
    const acceptSm = document.getElementById('consent-accept-sm');

    // show or hide bar based on localStorage
    function showBarIfNeeded(){
      try {
        if (!localStorage.getItem(BAR_KEY)) {
          consentBar.style.display = 'flex';
        } else {
          consentBar.style.display = 'none';
        }
      } catch (e) {
        consentBar.style.display = 'flex';
      }
    }

    // open modal
    function openModal() {
      backdrop.style.display = 'flex';
      backdrop.setAttribute('aria-hidden','false');
      // trap focus: focus the scrollable body
      const body = document.getElementById('terms-body');
      body.focus();
      document.addEventListener('keydown', handleKeyDown);
    }

    // close modal
    function closeModal() {
      backdrop.style.display = 'none';
      backdrop.setAttribute('aria-hidden','true');
      document.removeEventListener('keydown', handleKeyDown);
    }

    // Accept terms: set localStorage and hide bar & modal
    function acceptTerms() {
      try { localStorage.setItem(BAR_KEY, Date.now().toString()); } catch(e){}
      consentBar.style.display = 'none';
      closeModal();
      // optional: show a tiny non-intrusive toast confirmation
      showTinyToast('Thanks ‚Äî terms accepted.');
    }

    // Decline: redirect or block (here we politely close and keep bar)
    function declineTerms() {
      closeModal();
      showTinyToast('You declined. Access is limited until terms are accepted.');
    }

    function handleKeyDown(e) {
      if (e.key === 'Escape') closeModal();
      // simple focus trap: keep focus inside modal on Tab
      if (e.key === 'Tab') {
        const focusable = backdrop.querySelectorAll('button, [href], input, textarea, [tabindex]:not([tabindex="-1"])');
        if (!focusable.length) return;
        const first = focusable[0], last = focusable[focusable.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault(); last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault(); first.focus();
        }
      }
    }

    // tiny toast feedback (non-blocking)
    function showTinyToast(msg){
      const t = document.createElement('div');
      t.textContent = msg;
      Object.assign(t.style, {
        position:'fixed', right:'18px', bottom:'78px', background:'rgba(0,0,0,0.7)', color:'#fff',
        padding:'8px 12px', borderRadius:'8px', zIndex:100001, fontSize:'13px'
      });
      document.body.appendChild(t);
      setTimeout(()=> t.style.opacity = '0.0', 2500);
      setTimeout(()=> document.body.removeChild(t), 3200);
    }

    // event bindings
    openTerms.addEventListener('click', (e)=>{ e.preventDefault(); openModal(); });
    consentBar.querySelector('#consent-accept-sm').addEventListener('click', acceptTerms);
    closeBtn.addEventListener('click', closeModal);
    acceptBtn.addEventListener('click', acceptTerms);
    declineBtn.addEventListener('click', declineTerms);

    // initialize
    showBarIfNeeded();

    // OPTIONAL: if you want the bar to appear only after a delay (uncomment)
    // setTimeout(showBarIfNeeded, 2000);
  })();
</script>

</body>
</html>
