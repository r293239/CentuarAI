<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI - Advanced</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 700px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .info-section {
            margin: 5px;
        }

        #chessboard {
            width: 480px;
            height: 480px;
            margin: 20px auto;
            border: 2px solid #000;
            position: relative;
        }

        .square {
            width: 60px;
            height: 60px;
            float: left;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            user-select: none;
        }

        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        
        .square:hover {
            opacity: 0.8;
        }
        
        .selected {
            background-color: #87CEEB !important;
            box-shadow: inset 0 0 10px rgba(0,0,255,0.5);
        }
        
        .possible-move {
            background-color: #90EE90 !important;
        }

        .last-move {
            background-color: #FFE4B5 !important;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background: #5a6fd8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            background: #f9f9f9;
        }

        .thinking {
            text-align: center;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }

        .move-history {
            max-height: 150px;
            overflow-y: auto;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }

        .evaluation {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: #e8f4fd;
            border-radius: 5px;
            font-weight: bold;
        }

        .difficulty-controls {
            text-align: center;
            margin: 15px 0;
        }

        .difficulty-controls label {
            font-weight: bold;
            margin-right: 10px;
        }

        .difficulty-controls select {
            padding: 5px;
            font-size: 14px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Advanced Chess AI ‚ôõ</h1>
        
        <div class="game-info">
            <div class="info-section">
                <strong>Current Player:</strong> <span id="current-player">White</span>
            </div>
            <div class="info-section">
                <strong>You are:</strong> <span id="player-side">White</span>
            </div>
            <div class="info-section">
                <strong>Move:</strong> <span id="move-counter">1</span>
            </div>
        </div>

        <div class="difficulty-controls">
            <label for="difficulty">AI Difficulty:</label>
            <select id="difficulty" onchange="changeDifficulty()">
                <option value="1">Beginner (Depth 1)</option>
                <option value="2">Easy (Depth 2)</option>
                <option value="3">Normal (Depth 3)</option>
                <option value="4" selected>Hard (Depth 4)</option>
                <option value="5">Expert (Depth 5)</option>
                <option value="6">Master (Depth 6)</option>
            </select>
        </div>

        <div class="evaluation" id="evaluation">Position evaluation: 0.00</div>
        
        <div id="status" class="status">White to move</div>
        <div id="thinking" class="thinking" style="display: none;">ü§î AI is calculating... (depth: <span id="search-depth">4</span>)</div>
        
        <div id="chessboard"></div>
        
        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="undoMove()" id="undo-btn">Undo Move</button>
            <button onclick="switchSides()">Switch Sides</button>
            <button onclick="analyzePosition()" id="analyze-btn">Analyze</button>
        </div>
        
        <div class="move-history">
            <strong>Move History:</strong>
            <div id="move-list"></div>
        </div>
    </div>

    <script>
        // Enhanced chess board with better data structures
        let board = [
            ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
            ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
            ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
        ];

        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameHistory = [];
        let moveHistory = [];
        let gameOver = false;
        let humanPlayer = 'white';
        let aiDepth = 4;
        let moveCount = 1;
        let halfMoveCount = 0;
        let lastMove = null;
        let isAnalyzing = false;
        
        // Enhanced castling and game state tracking
        let castlingRights = {
            whiteKingside: true,
            whiteQueenside: true,
            blackKingside: true,
            blackQueenside: true
        };
        
        let enPassantTarget = null;
        let repetitionHistory = new Map();

        // Piece value mappings
        const pieceMap = {
            '‚ôú': 'r', '‚ôû': 'n', '‚ôù': 'b', '‚ôõ': 'q', '‚ôö': 'k', '‚ôü': 'p',
            '‚ôñ': 'R', '‚ôò': 'N', '‚ôó': 'B', '‚ôï': 'Q', '‚ôî': 'K', '‚ôô': 'P'
        };

        const symbolMap = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
        };

        // Enhanced opening book with more variations
        const openingBook = {
            "": [
                { move: "e2-e4", weight: 35 },
                { move: "d2-d4", weight: 30 },
                { move: "Ng1-f3", weight: 20 },
                { move: "c2-c4", weight: 15 }
            ],
            "e7-e5": [
                { move: "Ng1-f3", weight: 45 },
                { move: "Bf1-c4", weight: 25 },
                { move: "f2-f4", weight: 15 },
                { move: "Nb1-c3", weight: 15 }
            ],
            "e7-e5,Nb8-c6": [
                { move: "Bf1-c4", weight: 30 },
                { move: "Bf1-b5", weight: 25 },
                { move: "d2-d4", weight: 25 },
                { move: "Nb1-c3", weight: 20 }
            ],
            "d7-d5": [
                { move: "d2-d4", weight: 40 },
                { move: "c2-c4", weight: 30 },
                { move: "Ng1-f3", weight: 30 }
            ],
            "Ng8-f6": [
                { move: "d2-d4", weight: 35 },
                { move: "c2-c4", weight: 25 },
                { move: "Ng1-f3", weight: 25 },
                { move: "g2-g3", weight: 15 }
            ],
            "c7-c5": [
                { move: "Ng1-f3", weight: 35 },
                { move: "d2-d4", weight: 30 },
                { move: "Nb1-c3", weight: 20 },
                { move: "g2-g3", weight: 15 }
            ]
        };

        // Enhanced piece-square tables for better positional play
        const pieceSquareTables = {
            'P': [
                [0,   0,   0,   0,   0,   0,   0,   0],
                [50,  50,  50,  50,  50,  50,  50,  50],
                [10,  10,  20,  30,  30,  20,  10,  10],
                [5,   5,   10,  27,  27,  10,  5,   5],
                [0,   0,   0,   25,  25,  0,   0,   0],
                [5,   -5,  -10, 0,   0,   -10, -5,  5],
                [5,   10,  10,  -25, -25, 10,  10,  5],
                [0,   0,   0,   0,   0,   0,   0,   0]
            ],
            'N': [
                [-50, -40, -30, -30, -30, -30, -40, -50],
                [-40, -20, 0,   0,   0,   0,   -20, -40],
                [-30, 0,   10,  15,  15,  10,  0,   -30],
                [-30, 5,   15,  20,  20,  15,  5,   -30],
                [-30, 0,   15,  20,  20,  15,  0,   -30],
                [-30, 5,   10,  15,  15,  10,  5,   -30],
                [-40, -20, 0,   5,   5,   0,   -20, -40],
                [-50, -40, -30, -30, -30, -30, -40, -50]
            ],
            'B': [
                [-20, -10, -10, -10, -10, -10, -10, -20],
                [-10, 0,   0,   0,   0,   0,   0,   -10],
                [-10, 0,   5,   10,  10,  5,   0,   -10],
                [-10, 5,   5,   10,  10,  5,   5,   -10],
                [-10, 0,   10,  10,  10,  10,  0,   -10],
                [-10, 10,  10,  10,  10,  10,  10,  -10],
                [-10, 5,   0,   0,   0,   0,   5,   -10],
                [-20, -10, -10, -10, -10, -10, -10, -20]
            ],
            'R': [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5,  10, 10, 10, 10, 10, 10, 5],
                [-5, 0,  0,  0,  0,  0,  0,  -5],
                [-5, 0,  0,  0,  0,  0,  0,  -5],
                [-5, 0,  0,  0,  0,  0,  0,  -5],
                [-5, 0,  0,  0,  0,  0,  0,  -5],
                [-5, 0,  0,  0,  0,  0,  0,  -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ],
            'Q': [
                [-20, -10, -10, -5, -5, -10, -10, -20],
                [-10, 0,   0,   0,  0,  0,   0,   -10],
                [-10, 0,   5,   5,  5,  5,   0,   -10],
                [-5,  0,   5,   5,  5,  5,   0,   -5],
                [0,   0,   5,   5,  5,  5,   0,   -5],
                [-10, 5,   5,   5,  5,  5,   0,   -10],
                [-10, 0,   5,   0,  0,  0,   0,   -10],
                [-20, -10, -10, -5, -5, -10, -10, -20]
            ],
            'K': [
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-20, -30, -30, -40, -40, -30, -30, -20],
                [-10, -20, -20, -20, -20, -20, -20, -10],
                [20,  20,  0,   0,   0,   0,   20,  20],
                [20,  30,  10,  0,   0,   10,  30,  20]
            ]
        };

        // Endgame king table
        const kingEndgameTable = [
            [-50, -40, -30, -20, -20, -30, -40, -50],
            [-30, -20, -10, 0,   0,   -10, -20, -30],
            [-30, -10, 20,  30,  30,  20,  -10, -30],
            [-30, -10, 30,  40,  40,  30,  -10, -30],
            [-30, -10, 30,  40,  40,  30,  -10, -30],
            [-30, -10, 20,  30,  30,  20,  -10, -30],
            [-30, -30, 0,   0,   0,   0,   -30, -30],
            [-50, -30, -30, -30, -30, -30, -30, -50]
        ];

        function createBoard() {
            const boardElement = document.getElementById('chessboard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.id = `square-${row}-${col}`;
                    
                    if ((row + col) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }
                    
                    // Highlight last move
                    if (lastMove && 
                        ((lastMove.fromRow === row && lastMove.fromCol === col) ||
                         (lastMove.toRow === row && lastMove.toCol === col))) {
                        square.classList.add('last-move');
                    }
                    
                    square.textContent = board[row][col];
                    square.onclick = () => handleSquareClick(row, col);
                    
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameOver || currentPlayer !== humanPlayer || isAnalyzing) return;
            
            const square = document.getElementById(`square-${row}-${col}`);
            const piece = board[row][col];
            
            if (selectedSquare) {
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;
                
                if (fromRow === row && fromCol === col) {
                    clearSelection();
                    return;
                }
                
                if (isValidMove(fromRow, fromCol, row, col)) {
                    makeMove(fromRow, fromCol, row, col);
                    clearSelection();
                    switchPlayer();
                    updateStatus();
                    updateEvaluation();
                    
                    if (!gameOver && currentPlayer !== humanPlayer) {
                        setTimeout(makeAIMove, 300);
                    }
                } else {
                    if (piece && isPlayerPiece(piece, currentPlayer)) {
                        selectSquare(row, col);
                    } else {
                        clearSelection();
                    }
                }
            } else {
                if (piece && isPlayerPiece(piece, currentPlayer)) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            clearSelection();
            selectedSquare = { row, col };
            document.getElementById(`square-${row}-${col}`).classList.add('selected');
            showPossibleMoves(row, col);
        }

        function clearSelection() {
            selectedSquare = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'possible-move');
            });
            createBoard();
        }

        function showPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.getElementById(`square-${r}-${c}`);
                        square.classList.add('possible-move');
                    }
                }
            }
        }

        function isPlayerPiece(piece, player) {
            if (!piece) return false;
            const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
            const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
            
            if (player === 'white') {
                return whitePieces.includes(piece);
            } else {
                return blackPieces.includes(piece);
            }
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            if (!piece) return false;
            if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) return false;
            
            // Castling check
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                return canCastle(fromRow, fromCol, toRow, toCol);
            }
            
            // En passant check
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(toCol - fromCol) === 1 && !targetPiece && enPassantTarget) {
                if (toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                    return true;
                }
            }
            
            const pieceCode = pieceMap[piece];
            if (!isValidPieceMove(pieceCode, fromRow, fromCol, toRow, toCol)) return false;
            
            // Check if move leaves king in check
            return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol);
        }

        function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const originalTarget = board[toRow][toCol];
            
            // Handle en passant capture
            let capturedPawnRow = null;
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = '';
            }
            
            // Make temporary move
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            const inCheck = isKingInCheck(board, currentPlayer);
            
            // Restore board
            board[fromRow][fromCol] = piece;
            board[toRow][toCol] = originalTarget;
            
            if (capturedPawnRow !== null) {
                const capturedPawn = piece === '‚ôô' ? '‚ôü' : '‚ôô';
                board[capturedPawnRow][toCol] = capturedPawn;
            }
            
            return inCheck;
        }

        function canCastle(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const isWhite = piece === '‚ôî';
            const isKingside = toCol > fromCol;
            
            // Check castling rights
            if (isWhite) {
                if (isKingside && !castlingRights.whiteKingside) return false;
                if (!isKingside && !castlingRights.whiteQueenside) return false;
            } else {
                if (isKingside && !castlingRights.blackKingside) return false;
                if (!isKingside && !castlingRights.blackQueenside) return false;
            }
            
            // King must not be in check
            if (isKingInCheck(board, currentPlayer)) return false;
            
            // Check if rook is in place
            const rookCol = isKingside ? 7 : 0;
            const expectedRook = isWhite ? '‚ôñ' : '‚ôú';
            if (board[fromRow][rookCol] !== expectedRook) return false;
            
            // Check path is clear
            const start = Math.min(fromCol, rookCol) + 1;
            const end = Math.max(fromCol, rookCol);
            
            for (let col = start; col < end; col++) {
                if (board[fromRow][col] !== '') return false;
            }
            
            // Check king doesn't pass through or end in check
            const direction = isKingside ? 1 : -1;
            for (let col = fromCol; col !== toCol + direction; col += direction) {
                board[fromRow][col] = '';
                board[fromRow][col + direction] = piece;
                
                if (isKingInCheck(board, currentPlayer)) {
                    // Restore
                    board[fromRow][fromCol] = piece;
                    board[fromRow][col + direction] = '';
                    return false;
                }
            }
            
            // Restore king position
            board[fromRow][fromCol] = piece;
            board[fromRow][toCol] = '';
            
            return true;
        }

        function isValidPieceMove(piece, fromRow, fromCol, toRow, toCol) {
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (piece.toLowerCase()) {
                case 'p':
                    const direction = piece === 'P' ? -1 : 1;
                    const startRow = piece === 'P' ? 6 : 1;
                    
                    if (dx === 0) {
                        // Forward moves
                        if (dy === direction && !board[toRow][toCol]) return true;
                        if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol]) return true;
                    } else if (absDx === 1 && dy === direction && board[toRow][toCol]) {
                        // Diagonal captures
                        return true;
                    }
                    return false;
                    
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    
                case 'b':
                    return absDx === absDy && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClear(fromRow, fromCol, toRow, toCol);
                    
                case 'k':
                    return absDx <= 1 && absDy <= 1;
                    
                default:
                    return false;
            }
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Store game state for undo
            gameHistory.push({
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                moveHistory: [...moveHistory],
                moveCount: moveCount,
                halfMoveCount: halfMoveCount,
                castlingRights: { ...castlingRights },
                enPassantTarget: enPassantTarget,
                lastMove: lastMove
            });
            
            lastMove = { fromRow, fromCol, toRow, toCol };
            
            // Handle castling
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const rook = board[fromRow][rookFromCol];
                
                board[fromRow][rookToCol] = rook;
                board[fromRow][rookFromCol] = '';
            }
            
            // Handle en passant
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                const capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = '';
            }
            
            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            // Handle pawn promotion
            if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                const promotedPiece = getPromotionPiece(piece);
                board[toRow][toCol] = promotedPiece;
            }
            
            // Update game state
            updateCastlingRights(piece, fromRow, fromCol, toRow, toCol);
            updateEnPassantTarget(piece, fromRow, toRow, toCol);
            updateHalfMoveClock(piece, capturedPiece);
            
            if (currentPlayer === 'black') {
                moveCount++;
            }
            
            // Record move
            const moveNotation = getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece);
            moveHistory.push(moveNotation);
            updateMoveHistory();
            
            createBoard();
        }

        function getPromotionPiece(pawn) {
            if (currentPlayer !== humanPlayer) {
                return pawn === '‚ôô' ? '‚ôï' : '‚ôõ';
            }
            
            const isWhite = pawn === '‚ôô';
            const pieces = isWhite ? ['‚ôï', '‚ôñ', '‚ôó', '‚ôò'] : ['‚ôõ', '‚ôú', '‚ôù', '‚ôû'];
            
            let choice = 0;
            const userChoice = prompt(`Promote pawn to:\n0 - Queen\n1 - Rook\n2 - Bishop\n3 - Knight`, '0');
            if (userChoice !== null) {
                const num = parseInt(userChoice);
                if (num >= 0 && num <= 3) {
                    choice = num;
                }
            }
            
            return pieces[choice];
        }

        function updateCastlingRights(piece, fromRow, fromCol, toRow, toCol) {
            if (piece === '‚ôî') {
                castlingRights.whiteKingside = false;
                castlingRights.whiteQueenside = false;
            } else if (piece === '‚ôö') {
                castlingRights.blackKingside = false;
                castlingRights.blackQueenside = false;
            }
            
            // Rook moves
            if (piece === '‚ôñ' && fromRow === 7) {
                if (fromCol === 0) castlingRights.whiteQueenside = false;
                if (fromCol === 7) castlingRights.whiteKingside = false;
            }
            if (piece === '‚ôú' && fromRow === 0) {
                if (fromCol === 0) castlingRights.blackQueenside = false;
                if (fromCol === 7) castlingRights.blackKingside = false;
            }
            
            // Rook captures
            if (toRow === 7 && toCol === 0) castlingRights.whiteQueenside = false;
            if (toRow === 7 && toCol === 7) castlingRights.whiteKingside = false;
            if (toRow === 0 && toCol === 0) castlingRights.blackQueenside = false;
            if (toRow === 0 && toCol === 7) castlingRights.blackKingside = false;
        }

        function updateEnPassantTarget(piece, fromRow, toRow, toCol) {
            enPassantTarget = null;
            
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {
                    row: piece === '‚ôô' ? fromRow - 1 : fromRow + 1,
                    col: toCol
                };
            }
        }

        function updateHalfMoveClock(piece, capturedPiece) {
            if ((piece === '‚ôô' || piece === '‚ôü') || capturedPiece) {
                halfMoveCount = 0;
            } else {
                halfMoveCount++;
            }
        }

        function getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
            
            const fromSquare = files[fromCol] + ranks[fromRow];
            const toSquare = files[toCol] + ranks[toRow];
            
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                return toCol > fromCol ? 'O-O' : 'O-O-O';
            }
            
            let notation = '';
            
            if (piece === '‚ôü' || piece === '‚ôô') {
                if (capturedPiece || (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col)) {
                    notation = files[fromCol] + 'x' + toSquare;
                } else {
                    notation = toSquare;
                }
                
                if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                    const promotedPiece = board[toRow][toCol];
                    const promotionSymbol = promotedPiece === '‚ôï' || promotedPiece === '‚ôõ' ? 'Q' :
                                           promotedPiece === '‚ôñ' || promotedPiece === '‚ôú' ? 'R' :
                                           promotedPiece === '‚ôó' || promotedPiece === '‚ôù' ? 'B' : 'N';
                    notation += '=' + promotionSymbol;
                }
            } else {
                const pieceChar = piece === '‚ôû' || piece === '‚ôò' ? 'N' :
                                 piece === '‚ôù' || piece === '‚ôó' ? 'B' :
                                 piece === '‚ôú' || piece === '‚ôñ' ? 'R' :
                                 piece === '‚ôõ' || piece === '‚ôï' ? 'Q' :
                                 piece === '‚ôö' || piece === '‚ôî' ? 'K' : '';
                
                notation = pieceChar + (capturedPiece ? 'x' : '') + toSquare;
            }
            
            return notation;
        }

        function isKingInCheck(testBoard, player) {
            const kingSymbol = player === 'white' ? '‚ôî' : '‚ôö';
            let kingRow = -1, kingCol = -1;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (testBoard[row][col] === kingSymbol) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            if (kingRow === -1) return false;
            
            return isSquareAttacked(testBoard, kingRow, kingCol, player === 'white' ? 'black' : 'white');
        }

        function isSquareAttacked(testBoard, targetRow, targetCol, attackerColor) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = testBoard[row][col];
                    if (piece && isPlayerPiece(piece, attackerColor)) {
                        const pieceCode = pieceMap[piece];
                        if (canPieceAttack(pieceCode, row, col, targetRow, targetCol, testBoard)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canPieceAttack(piece, fromRow, fromCol, toRow, toCol, testBoard) {
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (piece.toLowerCase()) {
                case 'p':
                    const direction = piece === 'P' ? -1 : 1;
                    return absDx === 1 && dy === direction;
                    
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    
                case 'b':
                    return absDx === absDy && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                    
                case 'k':
                    return absDx <= 1 && absDy <= 1;
                    
                default:
                    return false;
            }
        }

        function isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (testBoard[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
            document.getElementById('move-counter').textContent = moveCount;
        }

        // ENHANCED AI ENGINE
        function makeAIMove() {
            if (gameOver) return;
            
            document.getElementById('thinking').style.display = 'block';
            document.getElementById('search-depth').textContent = aiDepth;
            
            setTimeout(() => {
                const aiPlayer = currentPlayer;
                let bestMove = null;
                
                try {
                    // Check for book moves first
                    if (moveCount <= 8 && moveHistory.length <= 15) {
                        bestMove = getOpeningMove();
                    }
                    
                    // Use enhanced minimax search
                    if (!bestMove) {
                        bestMove = getBestMove(aiPlayer, aiDepth);
                    }
                    
                    // Fallback to simple move
                    if (!bestMove) {
                        const moves = getAllPossibleMoves(aiPlayer);
                        bestMove = moves[0];
                    }
                    
                    if (bestMove) {
                        makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                        switchPlayer();
                        updateStatus();
                        updateEvaluation();
                    }
                } catch (e) {
                    console.error("AI error:", e);
                    const moves = getAllPossibleMoves(aiPlayer);
                    if (moves.length > 0) {
                        const fallbackMove = moves[0];
                        makeMove(fallbackMove.fromRow, fallbackMove.fromCol, fallbackMove.toRow, fallbackMove.toCol);
                        switchPlayer();
                        updateStatus();
                        updateEvaluation();
                    }
                }
                
                document.getElementById('thinking').style.display = 'none';
            }, 400);
        }

        function getBestMove(player, depth) {
            const moves = getAllPossibleMoves(player);
            if (moves.length === 0) return null;
            
            // Order moves by likely strength
            moves.sort((a, b) => orderMoves(b) - orderMoves(a));
            
            let bestMove = null;
            let bestScore = player === humanPlayer ? Infinity : -Infinity;
            let alpha = -Infinity;
            let beta = Infinity;
            
            for (const move of moves) {
                makeTemporaryMove(move);
                
                const score = minimax(depth - 1, 
                    player === 'white' ? 'black' : 'white', 
                    alpha, beta, player !== humanPlayer);
                
                undoTemporaryMove(move);
                
                if ((player !== humanPlayer && score > bestScore) || 
                    (player === humanPlayer && score < bestScore)) {
                    bestScore = score;
                    bestMove = move;
                }
                
                if (player !== humanPlayer) {
                    alpha = Math.max(alpha, score);
                } else {
                    beta = Math.min(beta, score);
                }
                
                if (beta <= alpha) break; // Alpha-beta pruning
            }
            
            return bestMove;
        }

        function orderMoves(move) {
            let score = 0;
            const piece = board[move.fromRow][move.fromCol];
            const target = board[move.toRow][move.toCol];
            
            // Prioritize captures
            if (target) {
                const targetValue = getPieceValue(target);
                const pieceValue = getPieceValue(piece);
                score += (targetValue - pieceValue / 10) * 100;
            }
            
            // Prioritize central moves
            const centerDistance = Math.abs(move.toRow - 3.5) + Math.abs(move.toCol - 3.5);
            score += (7 - centerDistance) * 10;
            
            // Prioritize piece development
            if (moveCount < 15) {
                const pieceType = piece.toLowerCase();
                if ((pieceType === '‚ôû' || pieceType === '‚ôò' || pieceType === '‚ôù' || pieceType === '‚ôó')) {
                    const backRank = isPlayerPiece(piece, 'white') ? 7 : 0;
                    if (move.fromRow === backRank) {
                        score += 50;
                    }
                }
            }
            
            return score;
        }

        function minimax(depth, player, alpha, beta, maximizing, isQuiescence = false) {
            if (depth === 0 || isQuiescence) {
                let score = evaluatePosition();
                
                // Quiescence search for captures
                if (depth === 0 && !isQuiescence) {
                    return quiescenceSearch(player, alpha, beta, maximizing, 3);
                }
                
                return score;
            }
            
            const moves = getAllPossibleMoves(player);
            
            if (moves.length === 0) {
                if (isKingInCheck(board, player)) {
                    // Checkmate - return high score with depth bonus for faster mates
                    return maximizing ? -10000 + depth : 10000 - depth;
                }
                return 0; // Stalemate
            }
            
            // Check for threefold repetition or 50-move rule
            if (halfMoveCount >= 100) return 0;
            
            moves.sort((a, b) => orderMoves(b) - orderMoves(a));
            
            if (maximizing) {
                let maxScore = -Infinity;
                for (const move of moves) {
                    makeTemporaryMove(move);
                    const score = minimax(depth - 1, player === 'white' ? 'black' : 'white', alpha, beta, false);
                    undoTemporaryMove(move);
                    
                    maxScore = Math.max(maxScore, score);
                    alpha = Math.max(alpha, score);
                    if (beta <= alpha) break;
                }
                return maxScore;
            } else {
                let minScore = Infinity;
                for (const move of moves) {
                    makeTemporaryMove(move);
                    const score = minimax(depth - 1, player === 'white' ? 'black' : 'white', alpha, beta, true);
                    undoTemporaryMove(move);
                    
                    minScore = Math.min(minScore, score);
                    beta = Math.min(beta, score);
                    if (beta <= alpha) break;
                }
                return minScore;
            }
        }

        function quiescenceSearch(player, alpha, beta, maximizing, depth) {
            if (depth <= 0) return evaluatePosition();
            
            const standPat = evaluatePosition();
            
            if (maximizing) {
                if (standPat >= beta) return beta;
                alpha = Math.max(alpha, standPat);
            } else {
                if (standPat <= alpha) return alpha;
                beta = Math.min(beta, standPat);
            }
            
            const captures = getAllCaptures(player);
            captures.sort((a, b) => orderMoves(b) - orderMoves(a));
            
            for (const move of captures) {
                makeTemporaryMove(move);
                const score = quiescenceSearch(player === 'white' ? 'black' : 'white', alpha, beta, !maximizing, depth - 1);
                undoTemporaryMove(move);
                
                if (maximizing) {
                    if (score >= beta) return beta;
                    alpha = Math.max(alpha, score);
                } else {
                    if (score <= alpha) return alpha;
                    beta = Math.min(beta, score);
                }
            }
            
            return maximizing ? alpha : beta;
        }

        function getAllCaptures(player) {
            const captures = [];
            const moves = getAllPossibleMoves(player);
            
            for (const move of moves) {
                if (board[move.toRow][move.toCol] || 
                    (enPassantTarget && move.toRow === enPassantTarget.row && move.toCol === enPassantTarget.col)) {
                    captures.push(move);
                }
            }
            
            return captures;
        }

        let tempMoveStack = [];

        function makeTemporaryMove(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            
            tempMoveStack.push({
                move: move,
                piece: piece,
                capturedPiece: capturedPiece,
                castlingRights: { ...castlingRights },
                enPassantTarget: enPassantTarget,
                halfMoveCount: halfMoveCount
            });
            
            // Handle en passant
            let enPassantCapture = null;
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                move.toRow === enPassantTarget.row && move.toCol === enPassantTarget.col) {
                const capturedPawnRow = piece === '‚ôô' ? move.toRow + 1 : move.toRow - 1;
                enPassantCapture = board[capturedPawnRow][move.toCol];
                board[capturedPawnRow][move.toCol] = '';
            }
            
            // Make move
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = '';
            
            // Update castling rights
            if (piece === '‚ôî') {
                castlingRights.whiteKingside = false;
                castlingRights.whiteQueenside = false;
            } else if (piece === '‚ôö') {
                castlingRights.blackKingside = false;
                castlingRights.blackQueenside = false;
            }
            
            updateEnPassantTarget(piece, move.fromRow, move.toRow, move.toCol);
            updateHalfMoveClock(piece, capturedPiece);
            
            tempMoveStack[tempMoveStack.length - 1].enPassantCapture = enPassantCapture;
        }

        function undoTemporaryMove(move) {
            const moveData = tempMoveStack.pop();
            
            // Restore piece positions
            board[moveData.move.fromRow][moveData.move.fromCol] = moveData.piece;
            board[moveData.move.toRow][moveData.move.toCol] = moveData.capturedPiece;
            
            // Restore en passant capture
            if (moveData.enPassantCapture) {
                const piece = moveData.piece;
                const capturedPawnRow = piece === '‚ôô' ? moveData.move.toRow + 1 : moveData.move.toRow - 1;
                board[capturedPawnRow][moveData.move.toCol] = moveData.enPassantCapture;
            }
            
            // Restore game state
            castlingRights = moveData.castlingRights;
            enPassantTarget = moveData.enPassantTarget;
            halfMoveCount = moveData.halfMoveCount;
        }

        // ENHANCED POSITION EVALUATION
        function evaluatePosition() {
            let score = 0;
            
            // Material and position evaluation
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = getPieceValue(piece) + getPositionValue(piece, row, col);
                        score += isPlayerPiece(piece, 'white') ? value : -value;
                    }
                }
            }
            
            // Advanced positional factors
            score += evaluatePawnStructure();
            score += evaluatePieceMobility();
            score += evaluateKingSafety();
            score += evaluateControlOfCenter();
            score += evaluateRookPosition();
            score += evaluateBishopPair();
            score += evaluateThreats();
            
            // Adjust based on game phase
            const gamePhase = getGamePhase();
            if (gamePhase > 0.7) { // Endgame
                score += evaluateEndgame();
            }
            
            return humanPlayer === 'white' ? score : -score;
        }

        function getPieceValue(piece) {
            const values = {
                '‚ôô': 100, '‚ôò': 320, '‚ôó': 330, '‚ôñ': 500, '‚ôï': 900, '‚ôî': 20000,
                '‚ôü': 100, '‚ôû': 320, '‚ôù': 330, '‚ôú': 500, '‚ôõ': 900, '‚ôö': 20000
            };
            return values[piece] || 0;
        }

        function getPositionValue(piece, row, col) {
            const pieceType = pieceMap[piece];
            const isWhite = isPlayerPiece(piece, 'white');
            const adjustedRow = isWhite ? 7 - row : row;
            
            if (!pieceSquareTables[pieceType.toUpperCase()]) return 0;
            
            let value = pieceSquareTables[pieceType.toUpperCase()][adjustedRow][col];
            
            // Use endgame king table in endgame
            if ((piece === '‚ôî' || piece === '‚ôö') && getGamePhase() > 0.7) {
                value = kingEndgameTable[adjustedRow][col];
            }
            
            return value * 0.1; // Scale down
        }

        function getGamePhase() {
            let materialCount = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece !== '‚ôî' && piece !== '‚ôö') {
                        materialCount += getPieceValue(piece);
                    }
                }
            }
            
            const maxMaterial = 7800; // Approximate starting material without kings
            return Math.max(0, 1 - (materialCount / maxMaterial));
        }

        function evaluatePawnStructure() {
            let score = 0;
            
            for (let col = 0; col < 8; col++) {
                let whitePawns = [];
                let blackPawns = [];
                
                for (let row = 0; row < 8; row++) {
                    if (board[row][col] === '‚ôô') whitePawns.push(row);
                    if (board[row][col] === '‚ôü') blackPawns.push(row);
                }
                
                // Doubled pawns penalty
                if (whitePawns.length > 1) score -= 20 * (whitePawns.length - 1);
                if (blackPawns.length > 1) score += 20 * (blackPawns.length - 1);
                
                // Isolated pawns penalty
                let whiteIsolated = whitePawns.length > 0;
                let blackIsolated = blackPawns.length > 0;
                
                for (let checkCol = Math.max(0, col - 1); checkCol <= Math.min(7, col + 1); checkCol += 2) {
                    if (checkCol === col) continue;
                    for (let row = 0; row < 8; row++) {
                        if (board[row][checkCol] === '‚ôô') whiteIsolated = false;
                        if (board[row][checkCol] === '‚ôü') blackIsolated = false;
                    }
                }
                
                if (whiteIsolated && whitePawns.length > 0) score -= 15;
                if (blackIsolated && blackPawns.length > 0) score += 15;
                
                // Passed pawns bonus
                for (const pawnRow of whitePawns) {
                    if (isPassed(pawnRow, col, true)) {
                        score += 30 + (7 - pawnRow) * 10;
                    }
                }
                
                for (const pawnRow of blackPawns) {
                    if (isPassed(pawnRow, col, false)) {
                        score -= 30 + pawnRow * 10;
                    }
                }
            }
            
            return score;
        }

        function isPassed(pawnRow, pawnCol, isWhite) {
            const direction = isWhite ? -1 : 1;
            const enemyPawn = isWhite ? '‚ôü' : '‚ôô';
            
            for (let col = Math.max(0, pawnCol - 1); col <= Math.min(7, pawnCol + 1); col++) {
                for (let row = pawnRow + direction; row >= 0 && row <= 7; row += direction) {
                    if (board[row][col] === enemyPawn) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        function evaluatePieceMobility() {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece !== '‚ôî' && piece !== '‚ôö' && piece !== '‚ôô' && piece !== '‚ôü') {
                        const mobility = getPieceMobility(row, col);
                        score += isPlayerPiece(piece, 'white') ? mobility : -mobility;
                    }
                }
            }
            
            return score;
        }

        function getPieceMobility(row, col) {
            let moves = 0;
            const piece = board[row][col];
            if (!piece) return 0;
            
            const tempPlayer = currentPlayer;
            currentPlayer = isPlayerPiece(piece, 'white') ? 'white' : 'black';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        moves++;
                    }
                }
            }
            
            currentPlayer = tempPlayer;
            return moves;
        }

        function evaluateKingSafety() {
            let score = 0;
            
            const whiteKing = findKing('white');
            const blackKing = findKing('black');
            
            if (whiteKing) {
                score += getKingSafetyScore(whiteKing.row, whiteKing.col, 'white');
            }
            
            if (blackKing) {
                score -= getKingSafetyScore(blackKing.row, blackKing.col, 'black');
            }
            
            return score;
        }

        function findKing(color) {
            const kingSymbol = color === 'white' ? '‚ôî' : '‚ôö';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingSymbol) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        function getKingSafetyScore(kingRow, kingCol, color) {
            let safety = 0;
            const isWhite = color === 'white';
            const gamePhase = getGamePhase();
            
            // In opening/middlegame, prefer king safety
            if (gamePhase < 0.7) {
                // Penalty for king in center
                const centerDistance = Math.abs(kingRow - 3.5) + Math.abs(kingCol - 3.5);
                safety += centerDistance * 5;
                
                // Bonus for castling
                if ((isWhite && kingCol > 5) || (!isWhite && kingCol > 5)) {
                    safety += 30; // Kingside castle
                } else if ((isWhite && kingCol < 3) || (!isWhite && kingCol < 3)) {
                    safety += 25; // Queenside castle
                }
                
                // Pawn shelter
                const pawnShield = isWhite ? '‚ôô' : '‚ôü';
                const direction = isWhite ? 1 : -1;
                
                for (let col = Math.max(0, kingCol - 1); col <= Math.min(7, kingCol + 1); col++) {
                    if (kingRow + direction >= 0 && kingRow + direction <= 7) {
                        if (board[kingRow + direction][col] === pawnShield) {
                            safety += 10;
                        }
                    }
                }
            }
            
            return safety;
        }

        function evaluateControlOfCenter() {
            let score = 0;
            const centerSquares = [[3,3], [3,4], [4,3], [4,4]];
            const extendedCenter = [[2,2], [2,3], [2,4], [2,5], [3,2], [3,5], [4,2], [4,5], [5,2], [5,3], [5,4], [5,5]];
            
            for (const [row, col] of centerSquares) {
                const piece = board[row][col];
                if (piece) {
                    score += isPlayerPiece(piece, 'white') ? 20 : -20;
                }
                
                // Control by attacks
                if (isSquareAttacked(board, row, col, 'white')) score += 5;
                if (isSquareAttacked(board, row, col, 'black')) score -= 5;
            }
            
            for (const [row, col] of extendedCenter) {
                const piece = board[row][col];
                if (piece) {
                    score += isPlayerPiece(piece, 'white') ? 5 : -5;
                }
            }
            
            return score;
        }

        function evaluateRookPosition() {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece === '‚ôñ' || piece === '‚ôú') {
                        const isWhite = piece === '‚ôñ';
                        
                        // Open files bonus
                        let openFile = true;
                        for (let r = 0; r < 8; r++) {
                            if (board[r][col] === '‚ôô' || board[r][col] === '‚ôü') {
                                openFile = false;
                                break;
                            }
                        }
                        
                        if (openFile) {
                            score += isWhite ? 25 : -25;
                        }
                        
                        // Semi-open files
                        let semiOpen = true;
                        const friendlyPawn = isWhite ? '‚ôô' : '‚ôü';
                        for (let r = 0; r < 8; r++) {
                            if (board[r][col] === friendlyPawn) {
                                semiOpen = false;
                                break;
                            }
                        }
                        
                        if (semiOpen && !openFile) {
                            score += isWhite ? 15 : -15;
                        }
                        
                        // 7th rank bonus
                        if ((isWhite && row === 1) || (!isWhite && row === 6)) {
                            score += isWhite ? 20 : -20;
                        }
                    }
                }
            }
            
            return score;
        }

        function evaluateBishopPair() {
            let whiteLight = false, whiteDark = false;
            let blackLight = false, blackDark = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece === '‚ôó') {
                        if ((row + col) % 2 === 0) {
                            whiteLight = true;
                        } else {
                            whiteDark = true;
                        }
                    } else if (piece === '‚ôù') {
                        if ((row + col) % 2 === 0) {
                            blackLight = true;
                        } else {
                            blackDark = true;
                        }
                    }
                }
            }
            
            let score = 0;
            if (whiteLight && whiteDark) score += 25;
            if (blackLight && blackDark) score -= 25;
            
            return score;
        }

        function evaluateThreats() {
            let score = 0;
            
            // Check for hanging pieces
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const isWhite = isPlayerPiece(piece, 'white');
                        const enemyColor = isWhite ? 'black' : 'white';
                        
                        if (isSquareAttacked(board, row, col, enemyColor)) {
                            const attackers = countAttackers(row, col, enemyColor);
                            const defenders = countAttackers(row, col, isWhite ? 'white' : 'black');
                            
                            if (attackers > defenders) {
                                const pieceValue = getPieceValue(piece);
                                score += isWhite ? -pieceValue * 0.5 : pieceValue * 0.5;
                            }
                        }
                    }
                }
            }
            
            return score;
        }

        function countAttackers(targetRow, targetCol, attackerColor) {
            let count = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPlayerPiece(piece, attackerColor)) {
                        const pieceCode = pieceMap[piece];
                        if (canPieceAttack(pieceCode, row, col, targetRow, targetCol, board)) {
                            count++;
                        }
                    }
                }
            }
            
            return count;
        }

        function evaluateEndgame() {
            let score = 0;
            const whiteKing = findKing('white');
            const blackKing = findKing('black');
            
            if (whiteKing && blackKing) {
                // In endgame, centralize king
                const whiteDistance = Math.abs(whiteKing.row - 3.5) + Math.abs(whiteKing.col - 3.5);
                const blackDistance = Math.abs(blackKing.row - 3.5) + Math.abs(blackKing.col - 3.5);
                
                score += (blackDistance - whiteDistance) * 10;
                
                // Opposition in king and pawn endgame
                if (isKingAndPawnEndgame()) {
                    const kingDistance = Math.abs(whiteKing.row - blackKing.row) + Math.abs(whiteKing.col - blackKing.col);
                    if (kingDistance === 2) {
                        score += currentPlayer === 'white' ? -20 : 20; // Opposition
                    }
                }
            }
            
            return score;
        }

        function isKingAndPawnEndgame() {
            let pieceCount = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece !== '‚ôî' && piece !== '‚ôö' && piece !== '‚ôô' && piece !== '‚ôü') {
                        pieceCount++;
                    }
                }
            }
            return pieceCount === 0;
        }

        function getOpeningMove() {
            const gameState = buildGameStateString();
            
            if (openingBook[gameState]) {
                const possibleMoves = openingBook[gameState];
                const totalWeight = possibleMoves.reduce((sum, move) => sum + move.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const moveData of possibleMoves) {
                    random -= moveData.weight;
                    if (random <= 0) {
                        const parsedMove = parseOpeningMove(moveData.move);
                        if (parsedMove && isValidMove(parsedMove.fromRow, parsedMove.fromCol, parsedMove.toRow, parsedMove.toCol)) {
                            return parsedMove;
                        }
                    }
                }
            }
            
            return null;
        }

        function buildGameStateString() {
            return moveHistory.slice(-6).join(',');
        }

        function parseOpeningMove(moveStr) {
            try {
                const parts = moveStr.split('-');
                if (parts.length !== 2) return null;
                
                const fromSquare = parts[0];
                const toSquare = parts[1];
                
                // Handle piece notation (e.g., "Ng1-f3")
                let fromFile, fromRank, toFile, toRank;
                
                if (fromSquare.length === 3) {
                    // Piece move like "Ng1"
                    fromFile = fromSquare.charCodeAt(1) - 97;
                    fromRank = 8 - parseInt(fromSquare.charAt(2));
                } else {
                    // Pawn move like "e2"
                    fromFile = fromSquare.charCodeAt(0) - 97;
                    fromRank = 8 - parseInt(fromSquare.charAt(1));
                }
                
                if (toSquare.length === 3) {
                    toFile = toSquare.charCodeAt(1) - 97;
                    toRank = 8 - parseInt(toSquare.charAt(2));
                } else {
                    toFile = toSquare.charCodeAt(0) - 97;
                    toRank = 8 - parseInt(toSquare.charAt(1));
                }
                
                if (fromFile >= 0 && fromFile <= 7 && fromRank >= 0 && fromRank <= 7 &&
                    toFile >= 0 && toFile <= 7 && toRank >= 0 && toRank <= 7) {
                    return {
                        fromRow: fromRank,
                        fromCol: fromFile,
                        toRow: toRank,
                        toCol: toFile
                    };
                }
            } catch (e) {
                console.log("Failed to parse move:", moveStr);
            }
            
            return null;
        }

        function getAllPossibleMoves(player) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                const oldPlayer = currentPlayer;
                                currentPlayer = player;
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    moves.push({ fromRow, fromCol, toRow, toCol });
                                }
                                currentPlayer = oldPlayer;
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function updateStatus() {
            const statusElement = document.getElementById('status');
            const playerName = currentPlayer === 'white' ? 'White' : 'Black';
            
            if (isKingInCheck(board, currentPlayer)) {
                const moves = getAllPossibleMoves(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = `Checkmate! ${playerName === 'White' ? 'Black' : 'White'} wins!`;
                    statusElement.style.backgroundColor = '#ffcccb';
                    gameOver = true;
                } else {
                    statusElement.textContent = `${playerName} is in check!`;
                    statusElement.style.backgroundColor = '#ffe4b5';
                }
            } else {
                const moves = getAllPossibleMoves(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = 'Stalemate! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                } else if (halfMoveCount >= 100) {
                    statusElement.textContent = '50-move rule! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                } else if (isInsufficientMaterial()) {
                    statusElement.textContent = 'Insufficient material! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                } else {
                    statusElement.textContent = `${playerName} to move`;
                    statusElement.style.backgroundColor = '#f9f9f9';
                }
            }
        }

        function isInsufficientMaterial() {
            const pieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece !== '‚ôî' && piece !== '‚ôö') {
                        pieces.push(piece);
                    }
                }
            }
            
            if (pieces.length === 0) return true; // King vs King
            if (pieces.length === 1) {
                const piece = pieces[0];
                return piece === '‚ôó' || piece === '‚ôù' || piece === '‚ôò' || piece === '‚ôû'; // King and minor piece
            }
            
            return false;
        }

        function updateEvaluation() {
            if (gameOver) return;
            
            const evaluation = evaluatePosition();
            const evalElement = document.getElementById('evaluation');
            
            let displayValue = (evaluation / 100).toFixed(2);
            let displayText = `Position evaluation: ${displayValue}`;
            
            if (Math.abs(evaluation) > 500) {
                if (evaluation > 0) {
                    displayText = `White is winning (+${Math.abs(parseFloat(displayValue))})`;
                } else {
                    displayText = `Black is winning (+${Math.abs(parseFloat(displayValue))})`;
                }
            } else if (Math.abs(evaluation) > 200) {
                if (evaluation > 0) {
                    displayText = `White has advantage (+${Math.abs(parseFloat(displayValue))})`;
                } else {
                    displayText = `Black has advantage (+${Math.abs(parseFloat(displayValue))})`;
                }
            } else if (Math.abs(evaluation) < 50) {
                displayText = `Position is equal (${displayValue})`;
            }
            
            evalElement.textContent = displayText;
            
            if (evaluation > 200) {
                evalElement.style.backgroundColor = '#e8f5e8';
            } else if (evaluation < -200) {
                evalElement.style.backgroundColor = '#ffe8e8';
            } else {
                evalElement.style.backgroundColor = '#e8f4fd';
            }
        }

        function updateMoveHistory() {
            const moveList = document.getElementById('move-list');
            let html = '';
            
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = moveHistory[i] || '';
                const blackMove = moveHistory[i + 1] || '';
                
                html += `${moveNumber}. ${whiteMove}`;
                if (blackMove) {
                    html += ` ${blackMove}`;
                }
                html += '<br>';
            }
            
            moveList.innerHTML = html;
            moveList.scrollTop = moveList.scrollHeight;
        }

        function changeDifficulty() {
            const difficulty = document.getElementById('difficulty').value;
            aiDepth = parseInt(difficulty);
        }

        function analyzePosition() {
            if (isAnalyzing) return;
            
            isAnalyzing = true;
            const analyzeBtn = document.getElementById('analyze-btn');
            analyzeBtn.textContent = 'Analyzing...';
            analyzeBtn.disabled = true;
            
            setTimeout(() => {
                try {
                    const evaluation = evaluatePosition();
                    const bestMove = getBestMove(currentPlayer, Math.min(aiDepth + 1, 5));
                    
                    let analysis = `Position evaluation: ${(evaluation / 100).toFixed(2)}\n`;
                    
                    if (bestMove) {
                        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                        const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                        const from = files[bestMove.fromCol] + ranks[bestMove.fromRow];
                        const to = files[bestMove.toCol] + ranks[bestMove.toRow];
                        analysis += `Best move: ${from}-${to}`;
                    }
                    
                    alert(analysis);
                } catch (e) {
                    alert('Analysis failed: ' + e.message);
                }
                
                isAnalyzing = false;
                analyzeBtn.textContent = 'Analyze';
                analyzeBtn.disabled = false;
            }, 100);
        }

        function newGame() {
            board = [
                ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
            ];
            
            currentPlayer = 'white';
            selectedSquare = null;
            gameHistory = [];
            moveHistory = [];
            moveCount = 1;
            halfMoveCount = 0;
            gameOver = false;
            lastMove = null;
            tempMoveStack = [];
            
            castlingRights = {
                whiteKingside: true,
                whiteQueenside: true,
                blackKingside: true,
                blackQueenside: true
            };
            
            enPassantTarget = null;
            repetitionHistory.clear();
            
            document.getElementById('current-player').textContent = 'White';
            document.getElementById('player-side').textContent = humanPlayer === 'white' ? 'White' : 'Black';
            document.getElementById('move-counter').textContent = '1';
            
            createBoard();
            updateStatus();
            updateEvaluation();
            updateMoveHistory();
            
            if (currentPlayer !== humanPlayer) {
                setTimeout(makeAIMove, 1000);
            }
        }

        function switchSides() {
            humanPlayer = humanPlayer === 'white' ? 'black' : 'white';
            document.getElementById('player-side').textContent = humanPlayer === 'white' ? 'White' : 'Black';
            
            clearSelection();
            
            if (!gameOver && currentPlayer !== humanPlayer && !isAnalyzing) {
                setTimeout(makeAIMove, 500);
            }
        }

        function undoMove() {
            if (gameHistory.length >= 1) {
                const lastState = gameHistory.pop();
                
                board = lastState.board;
                currentPlayer = lastState.currentPlayer;
                moveHistory = lastState.moveHistory;
                moveCount = lastState.moveCount;
                halfMoveCount = lastState.halfMoveCount;
                castlingRights = lastState.castlingRights;
                enPassantTarget = lastState.enPassantTarget;
                lastMove = lastState.lastMove;
                gameOver = false;
                
                document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
                document.getElementById('move-counter').textContent = moveCount;
                
                clearSelection();
                createBoard();
                updateStatus();
                updateEvaluation();
                updateMoveHistory();
            }
        }

        // Initialize the game
        createBoard();
        updateStatus();
        updateEvaluation();
        document.getElementById('player-side').textContent = 'White';
    </script>
</body>
</html>
