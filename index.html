<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI - 1500 ELO</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            max-width: 800px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            border: 2px solid rgba(102, 126, 234, 0.3);
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 0;
            margin: 20px auto;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .square.selected {
            background-color: #7fc8f8 !important;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(127, 200, 248, 0.7);
        }

        .square.possible-move {
            background-color: rgba(255, 255, 0, 0.6) !important;
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .thinking {
            text-align: center;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
            font-size: 18px;
        }

        .move-history {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0,0,0,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }

        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 8px;
        }

        .status.check { background-color: #ffebcd; color: #d2691e; }
        .status.checkmate { background-color: #ffe4e1; color: #dc143c; }
        .status.draw { background-color: #f0f8ff; color: #4682b4; }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Chess AI - 1500 ELO ‚ôõ</h1>
        
        <div class="game-info">
            <div><strong>Your Turn:</strong> <span id="current-player">White</span></div>
            <div><strong>AI Difficulty:</strong> 1500 ELO</div>
            <div><strong>Search Depth:</strong> <span id="search-depth">4</span></div>
        </div>
        
        <div id="status" class="status"></div>
        <div id="thinking" class="thinking" style="display: none;">ü§î AI is thinking...</div>
        
        <div id="chessboard" class="chessboard"></div>
        
        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="undoMove()" id="undo-btn">Undo Move</button>
            <button onclick="toggleDifficulty()" id="difficulty-btn">Increase Difficulty</button>
        </div>
        
        <div class="move-history">
            <strong>Move History:</strong>
            <div id="move-list"></div>
        </div>
    </div>

    <script>
        // Chess AI Implementation - Target 1500 ELO

        class ChessAI {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.gameHistory = [];
                this.moveHistory = [];
                this.searchDepth = 4;
                this.gameOver = false;
                
                // Piece values for evaluation
                this.pieceValues = {
                    'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000,
                    'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000
                };
                
                // Position tables for better piece placement
                this.pawnTable = [
                    [0,  0,  0,  0,  0,  0,  0,  0],
                    [50, 50, 50, 50, 50, 50, 50, 50],
                    [10, 10, 20, 30, 30, 20, 10, 10],
                    [5,  5, 10, 25, 25, 10,  5,  5],
                    [0,  0,  0, 20, 20,  0,  0,  0],
                    [5, -5,-10,  0,  0,-10, -5,  5],
                    [5, 10, 10,-20,-20, 10, 10,  5],
                    [0,  0,  0,  0,  0,  0,  0,  0]
                ];
                
                this.knightTable = [
                    [-50,-40,-30,-30,-30,-30,-40,-50],
                    [-40,-20,  0,  0,  0,  0,-20,-40],
                    [-30,  0, 10, 15, 15, 10,  0,-30],
                    [-30,  5, 15, 20, 20, 15,  5,-30],
                    [-30,  0, 15, 20, 20, 15,  0,-30],
                    [-30,  5, 10, 15, 15, 10,  5,-30],
                    [-40,-20,  0,  5,  5,  0,-20,-40],
                    [-50,-40,-30,-30,-30,-30,-40,-50]
                ];
                
                this.bishopTable = [
                    [-20,-10,-10,-10,-10,-10,-10,-20],
                    [-10,  0,  0,  0,  0,  0,  0,-10],
                    [-10,  0,  5, 10, 10,  5,  0,-10],
                    [-10,  5,  5, 10, 10,  5,  5,-10],
                    [-10,  0, 10, 10, 10, 10,  0,-10],
                    [-10, 10, 10, 10, 10, 10, 10,-10],
                    [-10,  5,  0,  0,  0,  0,  5,-10],
                    [-20,-10,-10,-10,-10,-10,-10,-20]
                ];
                
                this.renderBoard();
                this.updateStatus();
            }

            initializeBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            getPieceSymbol(piece) {
                const symbols = {
                    'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
                    'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
                };
                return symbols[piece] || '';
            }

            renderBoard() {
                const boardElement = document.getElementById('chessboard');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.textContent = this.getPieceSymbol(this.board[row][col]);
                        square.addEventListener('click', (e) => this.handleSquareClick(e));
                        boardElement.appendChild(square);
                    }
                }
            }

            handleSquareClick(event) {
                if (this.gameOver || this.currentPlayer === 'black') return;
                
                const row = parseInt(event.target.dataset.row);
                const col = parseInt(event.target.dataset.col);
                
                if (this.selectedSquare) {
                    if (this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        this.clearSelection();
                        return;
                    }
                    
                    if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                        this.clearSelection();
                        this.switchPlayer();
                        this.updateStatus();
                        
                        if (!this.gameOver) {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    } else {
                        this.selectSquare(row, col);
                    }
                } else {
                    this.selectSquare(row, col);
                }
            }

            selectSquare(row, col) {
                const piece = this.board[row][col];
                if (piece && this.isPieceOwnedByPlayer(piece, this.currentPlayer)) {
                    this.selectedSquare = { row, col };
                    this.highlightSquare(row, col);
                    this.highlightPossibleMoves(row, col);
                }
            }

            clearSelection() {
                this.selectedSquare = null;
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'possible-move');
                });
            }

            highlightSquare(row, col) {
                const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                square.classList.add('selected');
            }

            highlightPossibleMoves(row, col) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.isValidMove(row, col, r, c)) {
                            const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            square.classList.add('possible-move');
                        }
                    }
                }
            }

            isPieceOwnedByPlayer(piece, player) {
                if (!piece) return false;
                return player === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase();
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
                
                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];
                
                if (!piece) return false;
                if (targetPiece && this.isPieceOwnedByPlayer(targetPiece, this.currentPlayer)) return false;
                
                // Create a temporary board to test the move
                const tempBoard = this.board.map(row => [...row]);
                tempBoard[toRow][toCol] = piece;
                tempBoard[fromRow][fromCol] = null;
                
                // Check if move puts own king in check
                if (this.isKingInCheck(this.currentPlayer, tempBoard)) return false;
                
                return this.isPieceMoveLegal(piece, fromRow, fromCol, toRow, toCol);
            }

            isPieceMoveLegal(piece, fromRow, fromCol, toRow, toCol) {
                const dx = toCol - fromCol;
                const dy = toRow - fromRow;
                const absDx = Math.abs(dx);
                const absDy = Math.abs(dy);
                
                switch (piece.toLowerCase()) {
                    case 'p':
                        return this.isPawnMoveLegal(piece, fromRow, fromCol, toRow, toCol);
                    case 'r':
                        return (dx === 0 || dy === 0) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'n':
                        return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    case 'b':
                        return absDx === absDy && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'q':
                        return (dx === 0 || dy === 0 || absDx === absDy) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'k':
                        return absDx <= 1 && absDy <= 1;
                    default:
                        return false;
                }
            }

            isPawnMoveLegal(piece, fromRow, fromCol, toRow, toCol) {
                const isWhite = piece === piece.toUpperCase();
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                const dx = toCol - fromCol;
                const dy = toRow - fromRow;
                
                // Moving forward
                if (dx === 0) {
                    if (dy === direction && !this.board[toRow][toCol]) return true;
                    if (fromRow === startRow && dy === 2 * direction && !this.board[toRow][toCol] && !this.board[fromRow + direction][fromCol]) return true;
                }
                // Capturing diagonally
                else if (Math.abs(dx) === 1 && dy === direction && this.board[toRow][toCol]) {
                    return !this.isPieceOwnedByPlayer(this.board[toRow][toCol], isWhite ? 'white' : 'black');
                }
                
                return false;
            }

            isPathClear(fromRow, fromCol, toRow, toCol) {
                const dx = Math.sign(toCol - fromCol);
                const dy = Math.sign(toRow - fromRow);
                let currentRow = fromRow + dy;
                let currentCol = fromCol + dx;
                
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (this.board[currentRow][currentCol]) return false;
                    currentRow += dy;
                    currentCol += dx;
                }
                
                return true;
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                this.gameHistory.push({
                    board: this.board.map(row => [...row]),
                    currentPlayer: this.currentPlayer
                });
                
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                // Record move
                const moveNotation = this.getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece);
                this.moveHistory.push(moveNotation);
                this.updateMoveHistory();
                
                this.renderBoard();
            }

            getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
                const files = 'abcdefgh';
                const ranks = '87654321';
                const from = files[fromCol] + ranks[fromRow];
                const to = files[toCol] + ranks[toRow];
                const capture = capturedPiece ? 'x' : '';
                return `${piece}${from}${capture}${to}`;
            }

            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                document.getElementById('current-player').textContent = this.currentPlayer === 'white' ? 'White' : 'Black';
            }

            // AI LOGIC - Minimax with Alpha-Beta Pruning

            makeAIMove() {
                if (this.gameOver) return;
                
                document.getElementById('thinking').style.display = 'block';
                
                setTimeout(() => {
                    const bestMove = this.getBestMove();
                    if (bestMove) {
                        this.makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                        this.switchPlayer();
                        this.updateStatus();
                    }
                    document.getElementById('thinking').style.display = 'none';
                }, 100);
            }

            getBestMove() {
                const moves = this.getAllPossibleMoves('black');
                let bestMove = null;
                let bestScore = -Infinity;
                
                for (const move of moves) {
                    const tempBoard = this.makeTemporaryMove(move);
                    const score = this.minimax(tempBoard, this.searchDepth - 1, -Infinity, Infinity, false);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }

            minimax(board, depth, alpha, beta, maximizingPlayer) {
                if (depth === 0) {
                    return this.evaluatePosition(board);
                }
                
                const moves = this.getAllPossibleMovesForBoard(board, maximizingPlayer ? 'black' : 'white');
                
                if (moves.length === 0) {
                    // Checkmate or stalemate
                    if (this.isKingInCheckForBoard(board, maximizingPlayer ? 'black' : 'white')) {
                        return maximizingPlayer ? -10000 + (this.searchDepth - depth) : 10000 - (this.searchDepth - depth);
                    }
                    return 0; // Stalemate
                }
                
                if (maximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of moves) {
                        const tempBoard = this.makeTemporaryMoveOnBoard(board, move);
                        const eval = this.minimax(tempBoard, depth - 1, alpha, beta, false);
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break; // Alpha-beta pruning
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of moves) {
                        const tempBoard = this.makeTemporaryMoveOnBoard(board, move);
                        const eval = this.minimax(tempBoard, depth - 1, alpha, beta, true);
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break; // Alpha-beta pruning
                    }
                    return minEval;
                }
            }

            evaluatePosition(board = this.board) {
                let score = 0;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            const isWhite = piece === piece.toUpperCase();
                            const pieceValue = this.pieceValues[piece];
                            const positionValue = this.getPositionValue(piece, row, col);
                            
                            const totalValue = pieceValue + positionValue;
                            score += isWhite ? -totalValue : totalValue;
                        }
                    }
                }
                
                // Add mobility bonus
                const blackMoves = this.getAllPossibleMovesForBoard(board, 'black').length;
                const whiteMoves = this.getAllPossibleMovesForBoard(board, 'white').length;
                score += (blackMoves - whiteMoves) * 10;
                
                return score;
            }

            getPositionValue(piece, row, col) {
                const pieceType = piece.toLowerCase();
                const isWhite = piece === piece.toUpperCase();
                const adjustedRow = isWhite ? 7 - row : row;
                
                switch (pieceType) {
                    case 'p':
                        return this.pawnTable[adjustedRow][col];
                    case 'n':
                        return this.knightTable[adjustedRow][col];
                    case 'b':
                        return this.bishopTable[adjustedRow][col];
                    default:
                        return 0;
                }
            }

            getAllPossibleMoves(player) {
                return this.getAllPossibleMovesForBoard(this.board, player);
            }

            getAllPossibleMovesForBoard(board, player) {
                const moves = [];
                
                for (let fromRow = 0; fromRow < 8; fromRow++) {
                    for (let fromCol = 0; fromCol < 8; fromCol++) {
                        const piece = board[fromRow][fromCol];
                        if (piece && this.isPieceOwnedByPlayer(piece, player)) {
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (this.isValidMoveForBoard(board, fromRow, fromCol, toRow, toCol, player)) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
                
                return moves;
            }

            isValidMoveForBoard(board, fromRow, fromCol, toRow, toCol, player) {
                if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
                
                const piece = board[fromRow][fromCol];
                const targetPiece = board[toRow][toCol];
                
                if (!piece) return false;
                if (targetPiece && this.isPieceOwnedByPlayer(targetPiece, player)) return false;
                
                // Create a temporary board to test the move
                const tempBoard = board.map(row => [...row]);
                tempBoard[toRow][toCol] = piece;
                tempBoard[fromRow][fromCol] = null;
                
                // Check if move puts own king in check
                if (this.isKingInCheckForBoard(tempBoard, player)) return false;
                
                return this.isPieceMoveLegalForBoard(board, piece, fromRow, fromCol, toRow, toCol);
            }

            isPieceMoveLegalForBoard(board, piece, fromRow, fromCol, toRow, toCol) {
                const dx = toCol - fromCol;
                const dy = toRow - fromRow;
                const absDx = Math.abs(dx);
                const absDy = Math.abs(dy);
                
                switch (piece.toLowerCase()) {
                    case 'p':
                        return this.isPawnMoveLegalForBoard(board, piece, fromRow, fromCol, toRow, toCol);
                    case 'r':
                        return (dx === 0 || dy === 0) && this.isPathClearForBoard(board, fromRow, fromCol, toRow, toCol);
                    case 'n':
                        return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                    case 'b':
                        return absDx === absDy && this.isPathClearForBoard(board, fromRow, fromCol, toRow, toCol);
                    case 'q':
                        return (dx === 0 || dy === 0 || absDx === absDy) && this.isPathClearForBoard(board, fromRow, fromCol, toRow, toCol);
                    case 'k':
                        return absDx <= 1 && absDy <= 1;
                    default:
                        return false;
                }
            }

            isPawnMoveLegalForBoard(board, piece, fromRow, fromCol, toRow, toCol) {
                const isWhite = piece === piece.toUpperCase();
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                const dx = toCol - fromCol;
                const dy = toRow - fromRow;
                
                // Moving forward
                if (dx === 0) {
                    if (dy === direction && !board[toRow][toCol]) return true;
                    if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol] && !board[fromRow + direction][fromCol]) return true;
                }
                // Capturing diagonally
                else if (Math.abs(dx) === 1 && dy === direction && board[toRow][toCol]) {
                    return !this.isPieceOwnedByPlayer(board[toRow][toCol], isWhite ? 'white' : 'black');
                }
                
                return false;
            }

            isPathClearForBoard(board, fromRow, fromCol, toRow, toCol) {
                const dx = Math.sign(toCol - fromCol);
                const dy = Math.sign(toRow - fromRow);
                let currentRow = fromRow + dy;
                let currentCol = fromCol + dx;
                
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (board[currentRow][currentCol]) return false;
                    currentRow += dy;
                    currentCol += dx;
                }
                
                return true;
            }

            makeTemporaryMove(move) {
                return this.makeTemporaryMoveOnBoard(this.board, move);
            }

            makeTemporaryMoveOnBoard(board, move) {
                const newBoard = board.map(row => [...row]);
                const piece = newBoard[move.fromRow][move.fromCol];
                newBoard[move.toRow][move.toCol] = piece;
                newBoard[move.fromRow][move.fromCol] = null;
                return newBoard;
            }

            isKingInCheck(player, board = this.board) {
                return this.isKingInCheckForBoard(board, player);
            }

            isKingInCheckForBoard(board, player) {
                // Find the king
                let kingRow, kingCol;
                const kingSymbol = player === 'white' ? 'K' : 'k';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (board[row][col] === kingSymbol) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                    if (kingRow !== undefined) break;
                }
                
                if (kingRow === undefined) return false; // King not found
                
                // Check if any enemy piece can attack the king
                const enemyPlayer = player === 'white' ? 'black' : 'white';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && this.isPieceOwnedByPlayer(piece, enemyPlayer)) {
                            if (this.isPieceMoveLegalForBoard(board, piece, row, col, kingRow, kingCol)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }

            updateStatus() {
                const statusElement = document.getElementById('status');
                const currentPlayerName = this.currentPlayer === 'white' ? 'White' : 'Black';
                
                if (this.isKingInCheck(this.currentPlayer)) {
                    const moves = this.getAllPossibleMoves(this.currentPlayer);
                    if (moves.length === 0) {
                        statusElement.textContent = `Checkmate! ${currentPlayerName === 'White' ? 'Black' : 'White'} wins!`;
                        statusElement.className = 'status checkmate';
                        this.gameOver = true;
                    } else {
                        statusElement.textContent = `${currentPlayerName} is in check!`;
                        statusElement.className = 'status check';
                    }
                } else {
                    const moves = this.getAllPossibleMoves(this.currentPlayer);
                    if (moves.length === 0) {
                        statusElement.textContent = 'Stalemate! It\'s a draw!';
                        statusElement.className = 'status draw';
                        this.gameOver = true;
                    } else {
                        statusElement.textContent = `${currentPlayerName} to move`;
                        statusElement.className = 'status';
                    }
                }
            }

            updateMoveHistory() {
                const moveList = document.getElementById('move-list');
                moveList.innerHTML = this.moveHistory.map((move, index) => {
                    const moveNumber = Math.floor(index / 2) + 1;
                    const isWhiteMove = index % 2 === 0;
                    return isWhiteMove ? `${moveNumber}. ${move}` : ` ${move}<br>`;
                }).join('');
            }

            newGame() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.gameHistory = [];
                this.moveHistory = [];
                this.gameOver = false;
                document.getElementById('current-player').textContent = 'White';
                this.renderBoard();
                this.updateStatus();
                this.updateMoveHistory();
            }

            undoMove() {
                if (this.gameHistory.length >= 2) {
                    // Undo both player and AI moves
                    this.gameHistory.pop(); // Remove AI move
                    const lastState = this.gameHistory.pop(); // Remove player move
                    this.board = lastState.board;
                    this.currentPlayer = lastState.currentPlayer;
                    this.moveHistory.splice(-2, 2);
                    this.gameOver = false;
                    
                    document.getElementById('current-player').textContent = this.currentPlayer === 'white' ? 'White' : 'Black';
                    this.renderBoard();
                    this.updateStatus();
                    this.updateMoveHistory();
                }
            }

            increaseDifficulty() {
                this.searchDepth = Math.min(this.searchDepth + 1, 6);
                document.getElementById('search-depth').textContent = this.searchDepth;
                
                const difficultyBtn = document.getElementById('difficulty-btn');
                if (this.searchDepth === 6) {
                    difficultyBtn.textContent = 'Maximum Difficulty';
                    difficultyBtn.disabled = true;
                } else {
                    difficultyBtn.textContent = 'Increase Difficulty';
                }
            }
        }

        // Initialize the game
        let game = new ChessAI();

        // Global functions for buttons
        function newGame() {
            game.newGame();
        }

        function undoMove() {
            game.undoMove();
        }

        function toggleDifficulty() {
            game.increaseDifficulty();
        }
    </script>
</body>
</html>
