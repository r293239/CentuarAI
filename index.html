<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - AI Learning Edition</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 700px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .info-section {
            margin: 5px;
        }

        .game-mode {
            text-align: center;
            margin: 15px 0;
        }

        .game-mode label {
            font-weight: bold;
            margin-right: 10px;
        }

        .game-mode select {
            padding: 5px;
            font-size: 14px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        #chessboard {
            width: 480px;
            height: 480px;
            margin: 20px auto;
            border: 2px solid #000;
            position: relative;
        }

        .square {
            width: 60px;
            height: 60px;
            float: left;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }

        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        
        .square:hover {
            opacity: 0.8;
        }
        
        .selected {
            background-color: #87CEEB !important;
            box-shadow: inset 0 0 10px rgba(0,0,255,0.5);
        }
        
        .possible-move {
            background-color: #90EE90 !important;
            position: relative;
        }

        .possible-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 128, 0, 0.6);
            transform: translate(-50%, -50%);
        }

        .capture-move {
            background-color: #4169E1 !important;
            position: relative;
        }

        .capture-move::after {
            content: '';
            position: absolute;
            top: 2px;
            right: 2px;
            bottom: 2px;
            left: 2px;
            border: 3px solid rgba(65, 105, 225, 0.8);
            border-radius: 4px;
        }

        .last-move {
            background-color: #FFE4B5 !important;
        }

        .in-check {
            background-color: #FF6B6B !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 107, 107, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0); }
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        button:hover {
            background: #5a6fd8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            background: #f9f9f9;
        }

        .thinking {
            text-align: center;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }

        .move-history {
            max-height: 150px;
            overflow-y: auto;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }

        .evaluation {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: #e8f4fd;
            border-radius: 5px;
            font-weight: bold;
        }

        .ai-info {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: #f0f8ff;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
        }

        .sync-status {
            text-align: center;
            margin: 5px 0;
            padding: 5px;
            background: #e8f5e8;
            border-radius: 3px;
            font-size: 12px;
            color: #2d5a2d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Advanced Chess Game - AI Learning Edition ‚ôõ</h1>
        
        <div class="game-info">
            <div class="info-section">
                <strong>Current Player:</strong> <span id="current-player">White</span>
            </div>
            <div class="info-section">
                <strong>Game Mode:</strong> <span id="game-mode-display">vs AI</span>
            </div>
            <div class="info-section">
                <strong>Move:</strong> <span id="move-counter">1</span>
            </div>
        </div>

        <div class="game-mode">
            <label for="gameMode">Game Mode:</label>
            <select id="gameMode" onchange="changeGameMode()">
                <option value="ai">Player vs AI</option>
                <option value="player">Player vs Player</option>
            </select>
        </div>

        <div class="ai-info" id="ai-info">
            AI Games Played: <span id="games-played">0</span> | 
            Win Rate: <span id="win-rate">0%</span>
        </div>
        
        <div class="sync-status" id="sync-status">Ready to sync</div>
        
        <div class="evaluation" id="evaluation">Position evaluation: 0.00</div>
        
        <div id="status" class="status">White to move</div>
        <div id="thinking" class="thinking" style="display: none;">ü§î AI is calculating... (Depth: 6)</div>
        
        <div id="chessboard"></div>
        
        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="undoMove()" id="undo-btn">Undo Move</button>
            <button onclick="switchSides()" id="switch-sides-btn">Switch Sides</button>
        </div>
        
        <div class="move-history">
            <strong>Move History:</strong>
            <div id="move-list"></div>
        </div>
    </div>

    <script>
        // Chess board representation
        let board = [
            ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
            ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
            ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
        ];

        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameHistory = [];
        let moveHistory = [];
        let gameOver = false;
        let gameMode = 'ai';
        let humanPlayer = 'white';
        const aiDepth = 6; // Fixed depth
        let moveCount = 1;
        let halfMoveCount = 0;
        let lastMove = null;
        
        // AI Learning System
        let aiMemory = {
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            openingBook: {},
            endgamePatterns: {},
            positionEvaluations: new Map()
        };
        
        // GitHub sync variables
        const GITHUB_TOKEN = process.env.ACESS_KEY; // Fixed secret name
        const REPO_OWNER = 'your-username';
        const REPO_NAME = 'chess-ai-memory';
        const FILE_PATH = 'ai-memory.json';
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 10000; // 10 seconds
        
        // Game state tracking
        let castlingRights = {
            whiteKingside: true,
            whiteQueenside: true,
            blackKingside: true,
            blackQueenside: true
        };
        
        let enPassantTarget = null;
        let isThinking = false;

        // Piece mappings
        const pieceMap = {
            '‚ôú': 'r', '‚ôû': 'n', '‚ôù': 'b', '‚ôõ': 'q', '‚ôö': 'k', '‚ôü': 'p',
            '‚ôñ': 'R', '‚ôò': 'N', '‚ôó': 'B', '‚ôï': 'Q', '‚ôî': 'K', '‚ôô': 'P'
        };

        const symbolMap = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
        };

        // Piece values for evaluation
        const PIECE_VALUES = {
            '‚ôô': 100, '‚ôò': 320, '‚ôó': 330, '‚ôñ': 500, '‚ôï': 900, '‚ôî': 20000,
            '‚ôü': 100, '‚ôû': 320, '‚ôù': 330, '‚ôú': 500, '‚ôõ': 900, '‚ôö': 20000,
            '': 0
        };

        // Position-specific piece values
        const PAWN_TABLE = [
            [0,  0,  0,  0,  0,  0,  0,  0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5,  5, 10, 25, 25, 10,  5,  5],
            [0,  0,  0, 20, 20,  0,  0,  0],
            [5, -5,-10,  0,  0,-10, -5,  5],
            [5, 10, 10,-20,-20, 10, 10,  5],
            [0,  0,  0,  0,  0,  0,  0,  0]
        ];

        function createBoard() {
            const boardElement = document.getElementById('chessboard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.id = `square-${row}-${col}`;
                    
                    if ((row + col) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }
                    
                    // Highlight last move
                    if (lastMove && 
                        ((lastMove.fromRow === row && lastMove.fromCol === col) ||
                         (lastMove.toRow === row && lastMove.toCol === col))) {
                        square.classList.add('last-move');
                    }
                    
                    // Highlight king in check
                    const piece = board[row][col];
                    if ((piece === '‚ôî' && isKingInCheck(board, 'white')) ||
                        (piece === '‚ôö' && isKingInCheck(board, 'black'))) {
                        square.classList.add('in-check');
                    }
                    
                    square.textContent = board[row][col];
                    square.onclick = () => handleSquareClick(row, col);
                    
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameOver || isThinking) return;
            
            // In AI mode, only allow human player to move
            if (gameMode === 'ai' && currentPlayer !== humanPlayer) return;
            
            const piece = board[row][col];
            
            if (selectedSquare) {
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;
                
                // Clicking the same square deselects it
                if (fromRow === row && fromCol === col) {
                    clearSelection();
                    return;
                }
                
                // Try to make the move
                if (isValidMove(fromRow, fromCol, row, col)) {
                    makeMove(fromRow, fromCol, row, col);
                    clearSelection();
                    switchPlayer();
                    updateStatus();
                    updateEvaluation();
                    
                    // In AI mode, make AI move after human move
                    if (gameMode === 'ai' && !gameOver && currentPlayer !== humanPlayer) {
                        setTimeout(makeAIMove, 200);
                    }
                } else {
                    // Invalid move, try selecting new piece
                    if (piece && isPlayerPiece(piece, currentPlayer)) {
                        selectSquare(row, col);
                    } else {
                        clearSelection();
                    }
                }
            } else {
                // Select piece if it belongs to current player
                if (piece && isPlayerPiece(piece, currentPlayer)) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            clearSelection();
            selectedSquare = { row, col };
            document.getElementById(`square-${row}-${col}`).classList.add('selected');
            showPossibleMoves(row, col);
        }

        function clearSelection() {
            selectedSquare = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'possible-move', 'capture-move');
            });
            createBoard();
        }

        function showPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.getElementById(`square-${r}-${c}`);
                        if (board[r][c] && isPlayerPiece(board[r][c], currentPlayer === 'white' ? 'black' : 'white')) {
                            square.classList.add('capture-move');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                }
            }
        }

        function isPlayerPiece(piece, player) {
            if (!piece) return false;
            const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
            const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
            
            if (player === 'white') {
                return whitePieces.includes(piece);
            } else {
                return blackPieces.includes(piece);
            }
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            // Boundary check
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            // Must have a piece to move
            if (!piece) return false;
            
            // Can't capture own piece
            if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) return false;
            
            // Special case: castling - FIX THE CASTLING GLITCH
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2 && fromRow === toRow) {
                return canCastle(fromRow, fromCol, toRow, toCol);
            }
            
            // Check if piece can make this move
            const pieceCode = pieceMap[piece];
            if (!isValidPieceMove(pieceCode, fromRow, fromCol, toRow, toCol)) return false;
            
            // Check if move leaves king in check
            return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol);
        }

        function isValidPieceMove(piece, fromRow, fromCol, toRow, toCol) {
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (piece.toLowerCase()) {
                case 'p':
                    return isValidPawnMove(piece, fromRow, fromCol, toRow, toCol, dx, dy);
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClear(fromRow, fromCol, toRow, toCol);
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                case 'b':
                    return absDx === absDy && isPathClear(fromRow, fromCol, toRow, toCol);
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClear(fromRow, fromCol, toRow, toCol);
                case 'k':
                    // Fixed: King can only move 1 square unless castling
                    return absDx <= 1 && absDy <= 1;
                default:
                    return false;
            }
        }

        function isValidPawnMove(piece, fromRow, fromCol, toRow, toCol, dx, dy) {
            const direction = piece === 'P' ? -1 : 1;
            const startRow = piece === 'P' ? 6 : 1;
            const absDx = Math.abs(dx);
            
            // Forward moves
            if (dx === 0) {
                if (dy === direction && !board[toRow][toCol]) return true;
                if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol]) return true;
            }
            // Diagonal captures
            else if (absDx === 1 && dy === direction) {
                if (board[toRow][toCol]) return true;
                // En passant
                if (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                    return true;
                }
            }
            
            return false;
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const originalTarget = board[toRow][toCol];
            const originalEnPassant = enPassantTarget;
            
            // Handle en passant capture
            let capturedPawnRow = null;
            if (piece === '‚ôô' || piece === '‚ôü') {
                if (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                    capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                    board[capturedPawnRow][toCol] = '';
                }
            }
            
            // Make temporary move
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            const inCheck = isKingInCheck(board, currentPlayer);
            
            // Restore board
            board[fromRow][fromCol] = piece;
            board[toRow][toCol] = originalTarget;
            if (capturedPawnRow !== null) {
                const capturedPawn = currentPlayer === 'white' ? '‚ôü' : '‚ôô';
                board[capturedPawnRow][toCol] = capturedPawn;
            }
            enPassantTarget = originalEnPassant;
            
            return inCheck;
        }

        function canCastle(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const isWhite = piece === '‚ôî';
            const isKingside = toCol > fromCol;
            
            // Must be on correct row
            if ((isWhite && fromRow !== 7) || (!isWhite && fromRow !== 0)) return false;
            
            // Must move exactly 2 squares
            if (Math.abs(toCol - fromCol) !== 2) return false;
            
            // Check castling rights
            if (isWhite) {
                if (isKingside && !castlingRights.whiteKingside) return false;
                if (!isKingside && !castlingRights.whiteQueenside) return false;
            } else {
                if (isKingside && !castlingRights.blackKingside) return false;
                if (!isKingside && !castlingRights.blackQueenside) return false;
            }
            
            // King must not be in check
            if (isKingInCheck(board, currentPlayer)) return false;
            
            // Check if rook is in place
            const rookCol = isKingside ? 7 : 0;
            const expectedRook = isWhite ? '‚ôñ' : '‚ôú';
            if (board[fromRow][rookCol] !== expectedRook) return false;
            
            // Check path is clear
            const start = Math.min(fromCol, rookCol) + 1;
            const end = Math.max(fromCol, rookCol);
            
            for (let col = start; col < end; col++) {
                if (board[fromRow][col] !== '') return false;
            }
            
            // Check king doesn't pass through check
            const direction = isKingside ? 1 : -1;
            for (let i = 0; i <= 2; i++) {
                const testCol = fromCol + (direction * i);
                if (testCol >= 0 && testCol <= 7) {
                    // Temporarily place king
                    const originalPiece = board[fromRow][testCol];
                    board[fromRow][testCol] = piece;
                    if (testCol !== fromCol) board[fromRow][fromCol] = '';
                    
                    const inCheck = isKingInCheck(board, currentPlayer);
                    
                    // Restore
                    board[fromRow][fromCol] = piece;
                    board[fromRow][testCol] = originalPiece;
                    
                    if (inCheck) return false;
                }
            }
            
            return true;
        }

        function isKingInCheck(testBoard, player) {
            const kingSymbol = player === 'white' ? '‚ôî' : '‚ôö';
            let kingRow = -1, kingCol = -1;
            
            // Find king
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (testBoard[row][col] === kingSymbol) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            if (kingRow === -1) return false;
            
            return isSquareAttacked(testBoard, kingRow, kingCol, player === 'white' ? 'black' : 'white');
        }

        function isSquareAttacked(testBoard, targetRow, targetCol, attackerColor) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = testBoard[row][col];
                    if (piece && isPlayerPiece(piece, attackerColor)) {
                        if (canPieceAttack(piece, row, col, targetRow, targetCol, testBoard)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canPieceAttack(piece, fromRow, fromCol, toRow, toCol, testBoard) {
            const pieceCode = pieceMap[piece];
            const dx = toCol - fromCol;
            const dy = toRow - fromRow;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (pieceCode.toLowerCase()) {
                case 'p':
                    const direction = pieceCode === 'P' ? -1 : 1;
                    return absDx === 1 && dy === direction;
                case 'r':
                    return (dx === 0 || dy === 0) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                case 'n':
                    return (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                case 'b':
                    return absDx === absDy && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                case 'q':
                    return (dx === 0 || dy === 0 || absDx === absDy) && isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol);
                case 'k':
                    return absDx <= 1 && absDy <= 1;
                default:
                    return false;
            }
        }

        function isPathClearOnBoard(testBoard, fromRow, fromCol, toRow, toCol) {
            const dx = Math.sign(toCol - fromCol);
            const dy = Math.sign(toRow - fromRow);
            let currentRow = fromRow + dy;
            let currentCol = fromCol + dx;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (testBoard[currentRow][currentCol]) return false;
                currentRow += dy;
                currentCol += dx;
            }
            
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Store game state for undo
            gameHistory.push({
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                moveHistory: [...moveHistory],
                moveCount: moveCount,
                halfMoveCount: halfMoveCount,
                castlingRights: { ...castlingRights },
                lastMove: lastMove,
                enPassantTarget: enPassantTarget
            });
            
            lastMove = { fromRow, fromCol, toRow, toCol };
            
            // Handle en passant capture
            if ((piece === '‚ôô' || piece === '‚ôü') && enPassantTarget && 
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                const capturedPawnRow = piece === '‚ôô' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = '';
            }
            
            // Handle castling
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const rook = board[fromRow][rookFromCol];
                
                board[fromRow][rookToCol] = rook;
                board[fromRow][rookFromCol] = '';
            }
            
            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            // Handle pawn promotion
            if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                const promotedPiece = getPromotionPiece(piece);
                board[toRow][toCol] = promotedPiece;
            }
            
            // Update en passant target
            enPassantTarget = null;
            if ((piece === '‚ôô' || piece === '‚ôü') && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {
                    row: fromRow + (toRow - fromRow) / 2,
                    col: fromCol
                };
            }
            
            // Update game state
            updateCastlingRights(piece, fromRow, fromCol, toRow, toCol);
            updateHalfMoveClock(piece, capturedPiece);
            
            if (currentPlayer === 'black') {
                moveCount++;
            }
            
            // Record move for AI learning
            recordMoveForAI(piece, fromRow, fromCol, toRow, toCol, capturedPiece);
            
            // Record move notation
            const moveNotation = getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece);
            moveHistory.push(moveNotation);
            updateMoveHistory();
            
            createBoard();
        }

        function getPromotionPiece(pawn) {
            // AI always promotes to queen
            if (gameMode === 'ai' && currentPlayer !== humanPlayer) {
                return pawn === '‚ôô' ? '‚ôï' : '‚ôõ';
            }
            
            const isWhite = pawn === '‚ôô';
            const pieces = isWhite ? ['‚ôï', '‚ôñ', '‚ôó', '‚ôò'] : ['‚ôõ', '‚ôú', '‚ôù', '‚ôû'];
            
            let choice = 0;
            const userChoice = prompt(`Promote pawn to:\n0 - Queen\n1 - Rook\n2 - Bishop\n3 - Knight`, '0');
            if (userChoice !== null) {
                const num = parseInt(userChoice);
                if (num >= 0 && num <= 3) {
                    choice = num;
                }
            }
            
            return pieces[choice];
        }

        function updateCastlingRights(piece, fromRow, fromCol, toRow, toCol) {
            // King moves lose all castling rights
            if (piece === '‚ôî') {
                castlingRights.whiteKingside = false;
                castlingRights.whiteQueenside = false;
            } else if (piece === '‚ôö') {
                castlingRights.blackKingside = false;
                castlingRights.blackQueenside = false;
            }
            
            // Rook moves lose castling rights for that side
            if (piece === '‚ôñ' && fromRow === 7) {
                if (fromCol === 0) castlingRights.whiteQueenside = false;
                if (fromCol === 7) castlingRights.whiteKingside = false;
            }
            if (piece === '‚ôú' && fromRow === 0) {
                if (fromCol === 0) castlingRights.blackQueenside = false;
                if (fromCol === 7) castlingRights.blackKingside = false;
            }
            
            // Rook captures lose castling rights
            if (toRow === 7 && toCol === 0) castlingRights.whiteQueenside = false;
            if (toRow === 7 && toCol === 7) castlingRights.whiteKingside = false;
            if (toRow === 0 && toCol === 0) castlingRights.blackQueenside = false;
            if (toRow === 0 && toCol === 7) castlingRights.blackKingside = false;
        }

        function updateHalfMoveClock(piece, capturedPiece) {
            if ((piece === '‚ôô' || piece === '‚ôü') || capturedPiece) {
                halfMoveCount = 0;
            } else {
                halfMoveCount++;
            }
        }

        // AI Learning Functions
        function recordMoveForAI(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
            if (gameMode !== 'ai') return;
            
            const positionKey = getBoardHash();
            const move = { fromRow, fromCol, toRow, toCol };
            
            // Record opening moves (first 10 moves)
            if (moveHistory.length < 20) {
                const openingKey = moveHistory.join(',');
                if (!aiMemory.openingBook[openingKey]) {
                    aiMemory.openingBook[openingKey] = [];
                }
                aiMemory.openingBook[openingKey].push(move);
            }
            
            // Record position evaluations for learning
            const evaluation = evaluatePosition();
            aiMemory.positionEvaluations.set(positionKey, evaluation);
        }

        function getBoardHash() {
            // Simple hash of board position
            let hash = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    hash += board[row][col] || '.';
                }
            }
            return hash + currentPlayer;
        }

        function recordGameResult(result) {
            aiMemory.gamesPlayed++;
            
            if (result === 'win' && humanPlayer !== currentPlayer) {
                aiMemory.wins++;
            } else if (result === 'loss' && humanPlayer === currentPlayer) {
                aiMemory.losses++;
            } else if (result === 'draw') {
                aiMemory.draws++;
            }
            
            updateAIStats();
            scheduleSync();
        }

        function updateAIStats() {
            document.getElementById('games-played').textContent = aiMemory.gamesPlayed;
            const winRate = aiMemory.gamesPlayed > 0 ? 
                Math.round((aiMemory.wins / aiMemory.gamesPlayed) * 100) : 0;
            document.getElementById('win-rate').textContent = winRate + '%';
        }

        // GitHub Sync Functions
        async function syncToGitHub() {
            if (!GITHUB_TOKEN) return;
            
            try {
                document.getElementById('sync-status').textContent = 'Syncing...';
                
                const memoryData = {
                    ...aiMemory,
                    positionEvaluations: Array.from(aiMemory.positionEvaluations.entries()),
                    lastSync: new Date().toISOString()
                };
                
                const content = btoa(JSON.stringify(memoryData, null, 2));
                
                // Get current file SHA if it exists
                let sha = null;
                try {
                    const getResponse = await fetch(
                        `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`,
                        {
                            headers: {
                                'Authorization': `token ${GITHUB_TOKEN}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        }
                    );
                    
                    if (getResponse.ok) {
                        const fileData = await getResponse.json();
                        sha = fileData.sha;
                    }
                } catch (e) {
                    console.log('File might not exist, creating new one');
                }
                
                // Update or create file
                const updateResponse = await fetch(
                    `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${GITHUB_TOKEN}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Update AI memory - Games: ${aiMemory.gamesPlayed}`,
                            content: content,
                            sha: sha
                        })
                    }
                );
                
                if (updateResponse.ok) {
                    document.getElementById('sync-status').textContent = 'Synced successfully';
                    lastSyncTime = Date.now();
                } else {
                    throw new Error('Failed to sync');
                }
                
            } catch (error) {
                console.error('Sync failed:', error);
                document.getElementById('sync-status').textContent = 'Sync failed';
            }
        }

        async function loadFromGitHub() {
            if (!GITHUB_TOKEN) return;
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`,
                    {
                        headers: {
                            'Authorization': `token ${GITHUB_TOKEN}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (response.ok) {
                    const fileData = await response.json();
                    const content = JSON.parse(atob(fileData.content));
                    
                    aiMemory = {
                        ...content,
                        positionEvaluations: new Map(content.positionEvaluations || [])
                    };
                    
                    updateAIStats();
                    document.getElementById('sync-status').textContent = 'Loaded from GitHub';
                }
            } catch (error) {
                console.error('Failed to load from GitHub:', error);
            }
        }

        function scheduleSync() {
            if (Date.now() - lastSyncTime > SYNC_INTERVAL) {
                syncToGitHub();
            }
        }

        // Auto-sync every 10 seconds
        setInterval(() => {
            if (Date.now() - lastSyncTime >= SYNC_INTERVAL) {
                syncToGitHub();
            }
        }, SYNC_INTERVAL);

        function getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
            
            const fromSquare = files[fromCol] + ranks[fromRow];
            const toSquare = files[toCol] + ranks[toRow];
            
            // Castling notation
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                return toCol > fromCol ? 'O-O' : 'O-O-O';
            }
            
            let notation = '';
            
            if (piece === '‚ôü' || piece === '‚ôô') {
                // Pawn moves
                if (capturedPiece || (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col)) {
                    notation = files[fromCol] + 'x' + toSquare;
                } else {
                    notation = toSquare;
                }
                
                // Promotion
                if ((piece === '‚ôô' && toRow === 0) || (piece === '‚ôü' && toRow === 7)) {
                    const promotedPiece = board[toRow][toCol];
                    const promotionSymbol = promotedPiece === '‚ôï' || promotedPiece === '‚ôõ' ? 'Q' :
                                           promotedPiece === '‚ôñ' || promotedPiece === '‚ôú' ? 'R' :
                                           promotedPiece === '‚ôó' || promotedPiece === '‚ôù' ? 'B' : 'N';
                    notation += '=' + promotionSymbol;
                }
            } else {
                const pieceChar = piece === '‚ôû' || piece === '‚ôò' ? 'N' :
                                 piece === '‚ôù' || piece === '‚ôó' ? 'B' :
                                 piece === '‚ôú' || piece === '‚ôñ' ? 'R' :
                                 piece === '‚ôõ' || piece === '‚ôï' ? 'Q' :
                                 piece === '‚ôö' || piece === '‚ôî' ? 'K' : '';
                
                notation = pieceChar + (capturedPiece ? 'x' : '') + toSquare;
            }
            
            return notation;
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
            document.getElementById('move-counter').textContent = moveCount;
        }

        function updateStatus() {
            const statusElement = document.getElementById('status');
            const playerName = currentPlayer === 'white' ? 'White' : 'Black';
            
            if (isKingInCheck(board, currentPlayer)) {
                const moves = getAllPossibleMoves(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = `Checkmate! ${playerName === 'White' ? 'Black' : 'White'} wins!`;
                    statusElement.style.backgroundColor = '#ffcccb';
                    gameOver = true;
                    recordGameResult(playerName === 'White' ? 'loss' : 'win');
                } else {
                    statusElement.textContent = `${playerName} is in check!`;
                    statusElement.style.backgroundColor = '#ffe4b5';
                }
            } else {
                const moves = getAllPossibleMoves(currentPlayer);
                if (moves.length === 0) {
                    statusElement.textContent = 'Stalemate! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                    recordGameResult('draw');
                } else if (halfMoveCount >= 100) {
                    statusElement.textContent = '50-move rule! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                    recordGameResult('draw');
                } else if (isInsufficientMaterial()) {
                    statusElement.textContent = 'Insufficient material! It\'s a draw!';
                    statusElement.style.backgroundColor = '#e6e6fa';
                    gameOver = true;
                    recordGameResult('draw');
                } else {
                    statusElement.textContent = `${playerName} to move`;
                    statusElement.style.backgroundColor = '#f9f9f9';
                }
            }
        }

        function getAllPossibleMoves(player) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isPlayerPiece(piece, player)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                const oldPlayer = currentPlayer;
                                currentPlayer = player;
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    moves.push({ fromRow, fromCol, toRow, toCol });
                                }
                                currentPlayer = oldPlayer;
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function isInsufficientMaterial() {
            const pieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece !== '‚ôî' && piece !== '‚ôö') {
                        pieces.push(piece);
                    }
                }
            }
            
            // King vs King
            if (pieces.length === 0) return true;
            
            // King + minor piece vs King
            if (pieces.length === 1) {
                const piece = pieces[0];
                return piece === '‚ôó' || piece === '‚ôù' || piece === '‚ôò' || piece === '‚ôû';
            }
            
            // King + Bishop vs King + Bishop (same color squares)
            if (pieces.length === 2) {
                const bishops = pieces.filter(p => p === '‚ôó' || p === '‚ôù');
                if (bishops.length === 2) {
                    // Check if bishops are on same colored squares
                    let whiteBishopSquareColor = -1;
                    let blackBishopSquareColor = -1;
                    
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = board[row][col];
                            if (piece === '‚ôó') {
                                whiteBishopSquareColor = (row + col) % 2;
                            } else if (piece === '‚ôù') {
                                blackBishopSquareColor = (row + col) % 2;
                            }
                        }
                    }
                    
                    return whiteBishopSquareColor === blackBishopSquareColor;
                }
            }
            
            return false;
        }

        function updateEvaluation() {
            if (gameOver) return;
            
            const evaluation = evaluatePosition();
            const evalElement = document.getElementById('evaluation');
            
            let displayValue = (evaluation / 100).toFixed(2);
            let displayText = `Position evaluation: ${displayValue}`;
            
            if (Math.abs(evaluation) > 500) {
                if (evaluation > 0) {
                    displayText = `White is winning (+${Math.abs(parseFloat(displayValue))})`;
                } else {
                    displayText = `Black is winning (+${Math.abs(parseFloat(displayValue))})`;
                }
            } else if (Math.abs(evaluation) > 200) {
                if (evaluation > 0) {
                    displayText = `White has advantage (+${Math.abs(parseFloat(displayValue))})`;
                } else {
                    displayText = `Black has advantage (+${Math.abs(parseFloat(displayValue))})`;
                }
            } else if (Math.abs(evaluation) < 50) {
                displayText = `Position is equal (${displayValue})`;
            }
            
            evalElement.textContent = displayText;
            
            if (evaluation > 200) {
                evalElement.style.backgroundColor = '#e8f5e8';
            } else if (evaluation < -200) {
                evalElement.style.backgroundColor = '#ffe8e8';
            } else {
                evalElement.style.backgroundColor = '#e8f4fd';
            }
        }

        function evaluatePosition() {
            let score = 0;
            
            // Material evaluation
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = PIECE_VALUES[piece];
                        if (isPlayerPiece(piece, 'white')) {
                            score += value;
                            // Add positional bonuses
                            if (piece === '‚ôô') {
                                score += PAWN_TABLE[row][col];
                            }
                        } else {
                            score -= value;
                            // Add positional bonuses for black (flipped table)
                            if (piece === '‚ôü') {
                                score -= PAWN_TABLE[7 - row][col];
                            }
                        }
                    }
                }
            }
            
            // Use AI memory for position evaluation if available
            const positionKey = getBoardHash();
            if (aiMemory.positionEvaluations.has(positionKey)) {
                const memorizedEval = aiMemory.positionEvaluations.get(positionKey);
                score = (score + memorizedEval) / 2; // Average with memorized evaluation
            }
            
            return score;
        }

        function updateMoveHistory() {
            const moveList = document.getElementById('move-list');
            let html = '';
            
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = moveHistory[i] || '';
                const blackMove = moveHistory[i + 1] || '';
                
                html += `${moveNumber}. ${whiteMove}`;
                if (blackMove) {
                    html += ` ${blackMove}`;
                }
                html += '<br>';
            }
            
            moveList.innerHTML = html;
            moveList.scrollTop = moveList.scrollHeight;
        }

        // Enhanced AI Functions with Learning
        function makeAIMove() {
            if (gameOver || gameMode !== 'ai' || isThinking) return;
            
            isThinking = true;
            document.getElementById('thinking').style.display = 'block';
            
            setTimeout(() => {
                try {
                    const bestMove = getBestMoveWithLearning(currentPlayer);
                    
                    if (bestMove) {
                        makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                        switchPlayer();
                        updateStatus();
                        updateEvaluation();
                    }
                } catch (e) {
                    console.error("AI error:", e);
                    // Fallback to random move
                    const moves = getAllPossibleMoves(currentPlayer);
                    if (moves.length > 0) {
                        const randomMove = moves[Math.floor(Math.random() * moves.length)];
                        makeMove(randomMove.fromRow, randomMove.fromCol, randomMove.toRow, randomMove.toCol);
                        switchPlayer();
                        updateStatus();
                        updateEvaluation();
                    }
                }
                
                isThinking = false;
                document.getElementById('thinking').style.display = 'none';
            }, 100);
        }

        function getBestMoveWithLearning(player) {
            // First check opening book
            if (moveHistory.length < 20) {
                const openingKey = moveHistory.join(',');
                if (aiMemory.openingBook[openingKey]) {
                    const bookMoves = aiMemory.openingBook[openingKey];
                    const validBookMoves = bookMoves.filter(move => 
                        isValidMove(move.fromRow, move.fromCol, move.toRow, move.toCol)
                    );
                    
                    if (validBookMoves.length > 0) {
                        return validBookMoves[Math.floor(Math.random() * validBookMoves.length)];
                    }
                }
            }
            
            // Use minimax with learning
            const moves = getAllPossibleMoves(player);
            if (moves.length === 0) return null;
            
            let bestMove = null;
            let bestScore = player === 'white' ? -Infinity : Infinity;
            
            for (const move of moves) {
                const score = evaluateMoveWithMinimax(move, aiDepth - 1);
                
                if ((player === 'white' && score > bestScore) || 
                    (player === 'black' && score < bestScore)) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }

        function evaluateMoveWithMinimax(move, depth) {
            // Make temporary move
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            const oldEnPassant = enPassantTarget;
            
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = '';
            
            let score;
            if (depth <= 0) {
                score = evaluatePosition();
            } else {
                score = minimax(depth, currentPlayer === 'white' ? 'black' : 'white', -Infinity, Infinity);
            }
            
            // Restore board
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            enPassantTarget = oldEnPassant;
            
            return score;
        }

        function minimax(depth, player, alpha, beta) {
            if (depth <= 0) {
                return evaluatePosition();
            }
            
            const moves = getAllPossibleMoves(player);
            if (moves.length === 0) {
                if (isKingInCheck(board, player)) {
                    return player === 'white' ? -10000 : 10000;
                }
                return 0; // Stalemate
            }
            
            if (player === 'white') {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const piece = board[move.fromRow][move.fromCol];
                    const capturedPiece = board[move.toRow][move.toCol];
                    const oldEnPassant = enPassantTarget;
                    
                    board[move.toRow][move.toCol] = piece;
                    board[move.fromRow][move.fromCol] = '';
                    
                    const eval = minimax(depth - 1, 'black', alpha, beta);
                    
                    board[move.fromRow][move.fromCol] = piece;
                    board[move.toRow][move.toCol] = capturedPiece;
                    enPassantTarget = oldEnPassant;
                    
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const piece = board[move.fromRow][move.fromCol];
                    const capturedPiece = board[move.toRow][move.toCol];
                    const oldEnPassant = enPassantTarget;
                    
                    board[move.toRow][move.toCol] = piece;
                    board[move.fromRow][move.fromCol] = '';
                    
                    const eval = minimax(depth - 1, 'white', alpha, beta);
                    
                    board[move.fromRow][move.fromCol] = piece;
                    board[move.toRow][move.toCol] = capturedPiece;
                    enPassantTarget = oldEnPassant;
                    
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // Game Control Functions
        function changeGameMode() {
            const gameModeSelect = document.getElementById('gameMode');
            gameMode = gameModeSelect.value;
            
            const switchSidesBtn = document.getElementById('switch-sides-btn');
            const gameModeDisplay = document.getElementById('game-mode-display');
            const aiInfo = document.getElementById('ai-info');
            
            if (gameMode === 'ai') {
                switchSidesBtn.style.display = 'inline-block';
                gameModeDisplay.textContent = 'vs AI';
                aiInfo.style.display = 'block';
            } else {
                switchSidesBtn.style.display = 'none';
                gameModeDisplay.textContent = 'vs Player';
                aiInfo.style.display = 'none';
            }
            
            // Stop AI thinking if switching to player mode
            if (gameMode === 'player') {
                document.getElementById('thinking').style.display = 'none';
                isThinking = false;
            }
        }

        function switchSides() {
            if (gameMode !== 'ai') return;
            
            humanPlayer = humanPlayer === 'white' ? 'black' : 'white';
            clearSelection();
            
            if (!gameOver && currentPlayer !== humanPlayer && gameMode === 'ai') {
                setTimeout(makeAIMove, 300);
            }
        }

        function newGame() {
            // Reset board
            board = [
                ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
            ];
            
            // Reset game state
            currentPlayer = 'white';
            selectedSquare = null;
            gameHistory = [];
            moveHistory = [];
            moveCount = 1;
            halfMoveCount = 0;
            gameOver = false;
            lastMove = null;
            enPassantTarget = null;
            isThinking = false;
            
            castlingRights = {
                whiteKingside: true,
                whiteQueenside: true,
                blackKingside: true,
                blackQueenside: true
            };
            
            document.getElementById('current-player').textContent = 'White';
            document.getElementById('move-counter').textContent = '1';
            document.getElementById('thinking').style.display = 'none';
            
            createBoard();
            updateStatus();
            updateEvaluation();
            updateMoveHistory();
            
            // Start AI if needed
            if (gameMode === 'ai' && currentPlayer !== humanPlayer) {
                setTimeout(makeAIMove, 500);
            }
        }

        function undoMove() {
            if (gameHistory.length === 0) return;
            
            const lastState = gameHistory.pop();
            
            board = lastState.board;
            currentPlayer = lastState.currentPlayer;
            moveHistory = lastState.moveHistory;
            moveCount = lastState.moveCount;
            halfMoveCount = lastState.halfMoveCount;
            castlingRights = lastState.castlingRights;
            lastMove = lastState.lastMove;
            enPassantTarget = lastState.enPassantTarget;
            gameOver = false;
            isThinking = false;
            
            document.getElementById('current-player').textContent = currentPlayer === 'white' ? 'White' : 'Black';
            document.getElementById('move-counter').textContent = moveCount;
            document.getElementById('thinking').style.display = 'none';
            
            clearSelection();
            createBoard();
            updateStatus();
            updateEvaluation();
            updateMoveHistory();
        }

        // Initialize the game
        window.onload = async function() {
            // Load AI memory from GitHub
            await loadFromGitHub();
            
            createBoard();
            updateStatus();
            updateEvaluation();
            updateAIStats();
            changeGameMode(); // Set initial display state
            
            // Start periodic sync
            setInterval(() => {
                if (aiMemory.gamesPlayed > 0 && Date.now() - lastSyncTime >= SYNC_INTERVAL) {
                    syncToGitHub();
                }
            }, 1000); // Check every second
        };

        // Prevent pieces from randomly spawning by ensuring board state integrity
        function validateBoardState() {
            // Count pieces to prevent duplication
            const pieceCounts = {};
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        pieceCounts[piece] = (pieceCounts[piece] || 0) + 1;
                    }
                }
            }
            
            // Check for illegal piece counts (e.g., more than 8 pawns per side)
            const maxCounts = {
                '‚ôô': 8, '‚ôü': 8, // Pawns
                '‚ôñ': 2, '‚ôú': 2, // Rooks  
                '‚ôò': 2, '‚ôû': 2, // Knights
                '‚ôó': 2, '‚ôù': 2, // Bishops
                '‚ôï': 1, '‚ôõ': 1, // Queens
                '‚ôî': 1, '‚ôö': 1  // Kings
            };
            
            for (const [piece, count] of Object.entries(pieceCounts)) {
                if (count > maxCounts[piece]) {
                    console.warn(`Invalid piece count detected: ${piece} appears ${count} times`);
                    // Reset to starting position if corruption detected
                    newGame();
                    return false;
                }
            }
            
            return true;
        }

        // Enhanced error handling for move validation
        function safeIsValidMove(fromRow, fromCol, toRow, toCol) {
            try {
                // Validate board state first
                if (!validateBoardState()) return false;
                
                return isValidMove(fromRow, fromCol, toRow, toCol);
            } catch (error) {
                console.error("Error in move validation:", error);
                return false;
            }
        }

        // Override the original function with the safe version
        const originalIsValidMove = isValidMove;
        isValidMove = safeIsValidMove;

        // Add periodic board validation
        setInterval(() => {
            if (!gameOver && !isThinking) {
                validateBoardState();
            }
        }, 5000); // Check every 5 seconds

        // Enhanced GitHub integration with better error handling
        async function safeSyncToGitHub() {
            try {
                await syncToGitHub();
            } catch (error) {
                console.error("Sync error:", error);
                document.getElementById('sync-status').textContent = 'Sync error - retrying...';
                
                // Retry after 30 seconds
                setTimeout(() => {
                    safeSyncToGitHub();
                }, 30000);
            }
        }

        // Replace the original sync function
        syncToGitHub = safeSyncToGitHub;

        // Add connection status monitoring
        function updateConnectionStatus() {
            if (navigator.onLine) {
                document.getElementById('sync-status').style.backgroundColor = '#e8f5e8';
            } else {
                document.getElementById('sync-status').textContent = 'Offline - sync paused';
                document.getElementById('sync-status').style.backgroundColor = '#ffe8e8';
            }
        }

        window.addEventListener('online', updateConnectionStatus);
        window.addEventListener('offline', updateConnectionStatus);

        // Improve AI decision making with more sophisticated evaluation
        function getAdvancedEvaluation() {
            let score = evaluatePosition();
            
            // Add mobility bonus (number of legal moves)
            const whiteMoves = getAllPossibleMoves('white').length;
            const blackMoves = getAllPossibleMoves('black').length;
            score += (whiteMoves - blackMoves) * 2;
            
            // Add king safety evaluation
            score += evaluateKingSafety('white') - evaluateKingSafety('black');
            
            // Add control of center squares
            score += evaluateCenterControl();
            
            return score;
        }

        function evaluateKingSafety(player) {
            const kingSymbol = player === 'white' ? '‚ôî' : '‚ôö';
            let kingRow = -1, kingCol = -1;
            
            // Find king
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingSymbol) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            if (kingRow === -1) return -1000; // King missing (should not happen)
            
            let safety = 0;
            
            // Penalty for king in center during middle game
            if (moveCount < 30) {
                if (kingCol >= 2 && kingCol <= 5) safety -= 20;
                if (kingRow >= 2 && kingRow <= 5) safety -= 20;
            }
            
            // Bonus for castling
            const castled = player === 'white' ? 
                (!castlingRights.whiteKingside && !castlingRights.whiteQueenside) :
                (!castlingRights.blackKingside && !castlingRights.blackQueenside);
            
            if (castled) safety += 50;
            
            return safety;
        }

        function evaluateCenterControl() {
            let score = 0;
            const centerSquares = [[3,3], [3,4], [4,3], [4,4]];
            
            for (const [row, col] of centerSquares) {
                const piece = board[row][col];
                if (piece) {
                    if (isPlayerPiece(piece, 'white')) {
                        score += 10;
                    } else {
                        score -= 10;
                    }
                }
            }
            
            return score;
        }

        // Replace the basic evaluation with advanced evaluation
        const originalEvaluatePosition = evaluatePosition;
        evaluatePosition = function() {
            const basicEval = originalEvaluatePosition();
            const advancedEval = getAdvancedEvaluation();
            
            // Blend basic and advanced evaluation
            return Math.round((basicEval + advancedEval) / 2);
        };

        // Add game statistics tracking
        let gameStats = {
            totalMoves: 0,
            capturedPieces: 0,
            checksGiven: 0,
            castlingPerformed: false
        };

        function updateGameStats(piece, capturedPiece, fromRow, fromCol, toRow, toCol) {
            gameStats.totalMoves++;
            
            if (capturedPiece) {
                gameStats.capturedPieces++;
            }
            
            if (isKingInCheck(board, currentPlayer === 'white' ? 'black' : 'white')) {
                gameStats.checksGiven++;
            }
            
            if ((piece === '‚ôî' || piece === '‚ôö') && Math.abs(toCol - fromCol) === 2) {
                gameStats.castlingPerformed = true;
            }
        }

        // Enhanced move making with statistics
        const originalMakeMove = makeMove;
        makeMove = function(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            updateGameStats(piece, capturedPiece, fromRow, fromCol, toRow, toCol);
            originalMakeMove(fromRow, fromCol, toRow, toCol);
        };

        // Add performance monitoring
        let performanceMetrics = {
            aiThinkTime: [],
            movesPerSecond: 0,
            lastMoveTime: Date.now()
        };

        function updatePerformanceMetrics(thinkTime) {
            performanceMetrics.aiThinkTime.push(thinkTime);
            
            // Keep only last 10 measurements
            if (performanceMetrics.aiThinkTime.length > 10) {
                performanceMetrics.aiThinkTime.shift();
            }
            
            const avgThinkTime = performanceMetrics.aiThinkTime.reduce((a, b) => a + b, 0) / performanceMetrics.aiThinkTime.length;
            
            const currentTime = Date.now();
            const timeSinceLastMove = currentTime - performanceMetrics.lastMoveTime;
            performanceMetrics.movesPerSecond = timeSinceLastMove > 0 ? 1000 / timeSinceLastMove : 0;
            performanceMetrics.lastMoveTime = currentTime;
            
            console.log(`AI Performance - Avg Think Time: ${avgThinkTime.toFixed(0)}ms, Moves/sec: ${performanceMetrics.movesPerSecond.toFixed(2)}`);
        }

        console.log("‚ôî Advanced Chess Game with AI Learning System Loaded! ‚ôõ");
        console.log("Features: Fixed castling, AI memory, GitHub sync, enhanced evaluation");
    </script>
</body>
</html>
